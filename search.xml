<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Linux-Unix的基本命令(2)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/</url>
      
        <content type="html"><![CDATA[<p><strong>文件和目录基本操作命令</strong></p><h2 id="Shell命令特点"><a href="#Shell命令特点" class="headerlink" title="Shell命令特点"></a>Shell命令特点</h2><ul><li>Shell具有命令补齐（Command-Line Completion）的功能，它是指在键入的字符足以确定唯一一个文件时，按下 <code>&lt;Tab&gt;</code>键系统就会自动补齐该文件名的剩下部分。<br>例如：当键入 <code>&lt;[root@redflag /root] # hist&gt; </code>时，按下 <code>&lt;Tab&gt;</code>系统将会自动补齐 <code>&lt;[root@redflag /root] # history&gt;</code></li><li>Linux的命令区分大小写，且通常Linux的命令是小写的</li></ul><h2 id="ls命令-List-directory-contents"><a href="#ls命令-List-directory-contents" class="headerlink" title="ls命令-List directory contents"></a>ls命令-List directory contents</h2><ul><li>语法：ls[参数]文件名或路径</li><li>功能：列出文件或者子目录的信息</li><li>参数：<br><code>&lt;-a&gt;</code>：显示所有文件，包括以.开头的隐藏文件<br><code>&lt;-l&gt;</code>：以长格式显示文件或子目录的信息<br><code>&lt;-i&gt;</code>：显示每个文件的索引号<br><code>&lt;-R&gt;</code>：显示目录及下级子目录结构<br><code>&lt;-S&gt;</code>：以文件大小排序</li><li>ls -l以长格式显示文件或子目录的信息，如：<br><em>drwxr-xr-x 2 jjpr1 group 512 Nov 18 10：24</em><br><em>drwxrwxr-x 24 root auth 512 Nov 16 10：33</em></li><li>用颜色代表不同文件：<br>蓝色：目录<br>绿色：可执行文件<br>红色：压缩文件<br>浅蓝色：链接文件<br>灰色：其他文件</li><li>在ls -l显示结果中，第一个字符表示文件的类型：<br><code>&lt;d&gt;</code>：目录<br><code>&lt;-&gt;</code>：普通文件<br><code>&lt;c&gt;</code>：字符文件<br><code>&lt;b&gt;</code>：块设备<br><code>&lt;l&gt;</code>：链接文件</li><li>pwd - 打印用户当前所处目录</li><li>cd目录 - 改变当前目录</li></ul><h2 id="mkdir命令-make-directories-建立目录"><a href="#mkdir命令-make-directories-建立目录" class="headerlink" title="mkdir命令 - make directories 建立目录"></a>mkdir命令 - make directories 建立目录</h2><ul><li>语法：mkdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：当父目录不存在时，可将其连同子目录一起创建，即一次可建立多级目录<br><code>&lt;mkdir -p dir2/bak&gt;</code>：在dir2目录下建立子目录bak，如果dir2不存在则将它一同创立，在dir2目录事先存在时等同于 <code>&lt;mkdir dir2/bak&gt;</code></li></ul><h2 id="rmdir命令-remove-directories-删除目录"><a href="#rmdir命令-remove-directories-删除目录" class="headerlink" title="rmdir命令 - remove directories 删除目录"></a>rmdir命令 - remove directories 删除目录</h2><ul><li>语法：rmdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：一起删除父目录时父目录下应无其他目录<br><code>&lt;rmdir test&gt;</code>：删除当前目录下的test目录，被删除的test目录下应无其他文件或目录<br><code>&lt;rmdir -p longkey/test&gt;</code>：若longkey目录下除test外无其他目录或文件，则将它一同删除</li></ul><h2 id="cp命令-copy-files-复制文件"><a href="#cp命令-copy-files-复制文件" class="headerlink" title="cp命令 - copy files 复制文件"></a>cp命令 - copy files 复制文件</h2><ul><li>语法：cp [options] sourcefile destfile<br>cp [options] sourcefile … directory</li><li>作用：将一文件复制为另一文件，或是将多个文件复制到指定目录下</li><li>参数选项：<br><code>&lt;-p&gt;</code>：保持原始文件属性<br><code>&lt;-f&gt;</code>：如果目标文件已经存在，则覆盖它<br><code>&lt;-i&gt;</code>：提示是否要覆盖已有的目标文件<br><code>&lt;-r R&gt;</code>：递归复制目录，包括目录下的各级子目录。</li><li>目的目录不能在原目录下。如 <code>&lt;cp -r //targetdir&gt;</code>，会使系统进入死循环甚至瘫痪。<br><code>&lt;$ cp aaa bbb&gt;</code>：将文件aaa（已存在）复制并命名为bbb<br><code>&lt;$ cp *.c Finished&gt;</code>：将所有.c文件拷贝到Finished目录下</li></ul><h2 id="rm命令-remove-删除文件或目录"><a href="#rm命令-remove-删除文件或目录" class="headerlink" title="rm命令 - remove 删除文件或目录"></a>rm命令 - remove 删除文件或目录</h2><ul><li>语法：rm [-firR] file&#x2F;directory</li><li>参数选项：<br><code>&lt;-f&gt;</code>：不加提示的删除已存在的文件<br><code>&lt;-i&gt;</code>：交互删除<br><code>&lt;-r&gt;</code>：递归删除整个目录</li><li><code>&lt;rm -i *.c&gt;</code>：删除所有.c文件，并在删除前加以询问<br><code>&lt;rm -r finish&gt;</code>：删除finish目录下的所有文件和子目录</li></ul><h2 id="mv命令-move-移动文件或目录"><a href="#mv命令-move-移动文件或目录" class="headerlink" title="mv命令 - move 移动文件或目录"></a>mv命令 - move 移动文件或目录</h2><ul><li>语法：mv [-fi] source_file … target_directory<br>mv [-fi] source_file target_file</li><li>作用：将文件移动到指定目录下或将文件重命名</li><li>参数选项：<br><code>&lt;-f&gt;</code>：禁止提示<br><code>&lt;-i&gt;</code>：文件或目录重名时提示是否覆盖</li></ul><h2 id="tough命令-生成空文件或者修改文件的存取或修改时间"><a href="#tough命令-生成空文件或者修改文件的存取或修改时间" class="headerlink" title="tough命令 - 生成空文件或者修改文件的存取或修改时间"></a>tough命令 - 生成空文件或者修改文件的存取或修改时间</h2><ul><li>语法：tough [参数] 文件或者目录名</li><li>实例：</li><li><code>&lt;tough *&gt;</code> ：将当前目录下所有文件时间修改为当前系统时间<br><code>&lt;tough -d 20050912 test&gt;</code>：将文件test的时间修改为20050912<br><code>&lt;tough aaa&gt;</code>：如果aaa文件存在则将其修改为当前系统时间，如果不存在则创建文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux/Unix的基本命令(1)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>系统的登录、退出、启动和关闭</strong></p><ol><li>Linux是一个多用户的操作系统，注册用户想要使用Linux系统资源，必须登陆系统。</li><li>Linux将用户分为普通用户和超级用户。一般的Linux使用者均为普通用户，而系统管理员使用超级用户来进行文件管理等工作。</li><li>用户身份不同系统提示符也不同。<br>#：超级用户<br>$：普通用户</li></ol><h2 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h2><ol><li><p>系统启动后，输入用户名并键入回车符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login：root</span><br></pre></td></tr></table></figure></li><li><p>输入用户口令，输入的口令不会显示。如果输入错误，屏幕上会显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Login incorrect</span><br><span class="line">Login：</span><br></pre></td></tr></table></figure></li></ol><p>执行上述两步后，若屏幕显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loclhost root] #</span><br></pre></td></tr></table></figure><p>说明登录成功，可以进行操作</p><h2 id="系统退出"><a href="#系统退出" class="headerlink" title="系统退出"></a>系统退出</h2><p>用户在使用完成后退出系统的操作叫做注销，方法有三种：</p><ol><li>键入：exit</li><li>按Ctrl + D</li><li>logout</li></ol><h2 id="系统的启动与关闭"><a href="#系统的启动与关闭" class="headerlink" title="系统的启动与关闭"></a>系统的启动与关闭</h2><p>Linux在不使用系统资源时，需要关闭系统。必须由超级用户在shell提示符下，键入关闭命令，系统将完整的执行关闭所有进程，释放占用资源，停止运行。切断电源。</p><h3 id="关闭系统的命令："><a href="#关闭系统的命令：" class="headerlink" title="关闭系统的命令："></a>关闭系统的命令：</h3><p><code>[root@loclhost /root] # shutdown -h now</code></p><p><code>[root@loclhost /root] # halt</code></p><p><code>[root@loclhost /root] # init 0</code></p><p><code>[root@loclhost /root] # poweroff</code></p><h3 id="重启系统的命令："><a href="#重启系统的命令：" class="headerlink" title="重启系统的命令："></a>重启系统的命令：</h3><p>reboot 命令</p><p>shutdown -r <code>&lt;time&gt;</code> 命令</p><p>组合键Ctrl + Alt + Del</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机启动原理与操作系统的目标</title>
      <link href="/2022/09/13/post1/"/>
      <url>/2022/09/13/post1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机是如何启动（boot）的？"><a href="#计算机是如何启动（boot）的？" class="headerlink" title="计算机是如何启动（boot）的？"></a>计算机是如何启动（boot）的？</h1><p><strong>计算机的启动分为四个阶段</strong></p><h2 id="第一阶段：BIOS（Basic-Input-x2F-Output-System）"><a href="#第一阶段：BIOS（Basic-Input-x2F-Output-System）" class="headerlink" title="第一阶段：BIOS（Basic Input&#x2F;Output System）"></a>第一阶段：BIOS（Basic Input&#x2F;Output System）</h2><ul><li>硬件自检：首先检查计算机硬件是否能够满足计算机运行的基本需求（Power-On Self-Test）</li><li>启动顺序：在BIOS完成对硬件的自检之后，会将控制权转交给下一阶段的启动程序，这时BIOS需要知道下一阶段的启动程序储存在何处，因此BIOS需要一个关于外部储存设备的排序，排在前面的设备优先转交控制权。这种排序被称为启动顺序（Boot Sequence）</li></ul><h2 id="第二阶段：主引导顺序"><a href="#第二阶段：主引导顺序" class="headerlink" title="第二阶段：主引导顺序"></a>第二阶段：主引导顺序</h2><ul><li>BIOS根据启动顺序将控制权转交给对应的外部储存设备。即根据用户指定的引导顺序从硬盘、软盘或是可移动设备中读取启动设备的MBR（Master Boot Recort），并放入指定内存位置0x7c00。</li></ul><p><strong>分区表：</strong></p><p>计算机读取该设备的第一个扇区，即该设备的前512个字节，来得到启动程序的具体位置。</p><p>如果该设备的第一个扇区最后两个字节是0x55和0xAA（二进制分别是01010101和10101010，0和1交替做识别码），则该设备储存了正确的启动程序；反之则需要将控制权按启动顺序转交给下一存储设备。<br><img src="/./post1/20220913211755.png"></p><h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><ul><li>计算机的控制权转交给硬盘的某个分区</li><li>该分区的第一个扇区被激活，叫主引导扇区（Volume boot record），用于告诉计算机操作系统在这个分区中的位置。然后计算机就会把操作系统加载到内存中。</li></ul><p><em>当计算机中存在多种操作系统时，计算机读取主引导扇区的前446字节的机械码之后，不会将控制权直接转交某一分区，而是启动事先安装的启动管理器（Boot Loader）,由用户选择使用哪一个操作系统。</em></p><p><img src="/./post1/20220913211814.png"></p><h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><ul><li>控制权转交操作系统之后，操作系统的内核首先被加载入内存中。</li><li>以Linux系统为例，先载入&#x2F;boot目录下的是kernel。</li><li>内核加载完毕后，第一个运行的程序是&#x2F;sbin&#x2F;init，他根据配置文件生成init进程。这是Linux系统启动后生成的第一个进程，pid进程编号为1，其他进程都是他的后代。</li><li>然后init进程加载系统的各个模块，例如窗口模块和网络模块，直到执行&#x2F;bin&#x2F;login程序，跳出登入界面，等待用户输入账号和密码。</li></ul><h1 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h1><h2 id="OS的目标"><a href="#OS的目标" class="headerlink" title="OS的目标"></a>OS的目标</h2><ul><li>提高系统资源的利用率：使计算机资源更好更充分的被用户利用</li><li>提高系统效率：效率的提高可以缩短完成每项任务的时间，提高<em>系统吞吐量</em></li><li>方便性：方便使用</li><li>可扩充性：系统功能的改变和结构的扩充不影响原有功能的使用</li><li>开放性：不同的计算机和设备能够被集成起来有效使用</li></ul><h2 id="推动操作系统发展的因素"><a href="#推动操作系统发展的因素" class="headerlink" title="推动操作系统发展的因素"></a>推动操作系统发展的因素</h2><ul><li>计算机硬件升级和新的硬件类型发展</li><li>用户需求扩大</li><li>计算机体系结构的不断发展</li><li>市场的激烈竞争，OS功能的不断完善</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
