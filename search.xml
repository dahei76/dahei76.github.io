<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程</title>
      <link href="/2022/09/25/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/09/25/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="进程的不足"><a href="#进程的不足" class="headerlink" title="进程的不足"></a>进程的不足</h3><p>进程的两个基本属性：</p><ul><li>资源的拥有者：每个进程均有一虚拟地址，保存进程影像，控制内存、I&#x2F;O设备等资源，有状态、优先级、调度等。</li><li>调度单元：进程是一执行轨迹</li></ul><p>这两个属性构成了进程并发进行的基础</p><p>系统必须完成的操作：创建进程、撤销进程、进程切换</p><ul><li>当进程被创建时，系统要为它分配PCB和内存等必要的资源；当进程被终止时，系统需要回收这些资源，这就给系统增加了开销</li><li>当进程运行时，进程的来回切换也需要一定的系统资源来保存当前执行进程的CPU现场和为选中的进程重新布置CPU现场</li></ul><p>缺点：时间开销更大，限制了并发进行的程度。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li>目的：减少进程切换和创建撤销的开销，提高执行效率，节约资源</li><li>实现：将进程的资源申请和调度属性分开，进程只负责资源的申请和拥有，不负责资源的调度。资源的调度由线程来进行。</li><li>线程：是进程中的一个实体，负责资源的调度和分派。</li></ul><h2 id="单线程进程和多线程进程"><a href="#单线程进程和多线程进程" class="headerlink" title="单线程进程和多线程进程"></a>单线程进程和多线程进程</h2><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664110616170.png" alt="1664110616170"></p><p>线程是CPU运行的一个基本单位，包括：</p><ul><li>程序计数器</li><li>寄存器集</li><li>栈空间</li></ul><p>一个线程与它的对等线程共享：</p><ul><li>代码段</li><li>数据段</li><li>操作系统资源</li></ul><p><strong>传统的进程相当于只有一个线程的进程</strong></p><h3 id="单线程进程与多线程进程在实际应用上的比较"><a href="#单线程进程与多线程进程在实际应用上的比较" class="headerlink" title="单线程进程与多线程进程在实际应用上的比较"></a>单线程进程与多线程进程在实际应用上的比较</h3><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664111100222.png" alt="1664111100222"></p><p>以我们常用的word软件举例，假如进程中只有一个线程：</p><ul><li>当我们在文档第一页输入文字，会影响后文的排版，假如后文有成百上千页文档，则之后的排版需要数秒的时间来完成。在我们完成输入之后，输入进程进入Ready态，排版进程进入Running态。在排版进程运行中，输入进程不能执行，无法进行输入。</li><li>当我们在文档中进行了较多的修改，此时保存文档，保存进程运行中，输入进程不能进行，无法进行输入操作。</li></ul><p>而在实际情况下，通常存在着多个线程，保证了上述操作可以同时进行。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>响应度高：网页浏览（文本线程、图像线程……）</li><li>资源利用率高：进程创建的开销较大，而且当多个线程所需数据资源较为相似时，资源的利用率很高。</li><li>充分利用了多处理器体系结构</li></ul><h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><h2 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h2><ul><li>利用用户级的线程库进行管理</li><li>在用户层通过线程库来支持。三个主要的线程库：<br>POSIX Pthreads<br>Win32 threads<br>Java threads</li><li>线程库提供对线程的创建、调度和管理，无序用户干预</li><li>内核不知道现成的存在</li></ul><p><strong>缺点</strong>：如果内核是单线程的，那么当进程内一个用户级线程执行系统调用时就会引起整个进程的阻塞，即使进程内的其他线程可以正常执行</p><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664197976542.png" alt="1664197976542"></p><ol><li>a-&gt;b：进程2执行的程序进行了一次系统调用，阻塞了进程P（比如进行了一次I&#x2F;O），将控制权转交给了内核，内核启动了I&#x2F;O操作，并切换到另一个进程。根据线程库维护的数据结构，检测线程2依然处于运行态。</li><li>a-&gt;c：当进程P将时间片用完之后，控制转交给内核，内核将进程P置为就绪态并切换到另一个进程。根据线程库维护的数据结构，检测线程2依然处于运行态。</li><li>a-&gt;d：当线程2在运行过程中需要线程1执行产生足够资源，线程2进入阻塞态，线程1进入运行态。由于内核不知道线程的存在，而线程2只需进程P之内的资源而无需向外部申请资源，所以进程P依旧处于运行态。</li></ol><h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><ul><li>内核支持</li><li>操作系统内核负责线程的创建、调度和管理</li><li>内核直接管理线程，所以当一个线程进入阻塞态时，内核会调度当前进程下的其他线程来执行</li><li>在多处理器环境下，内核能在多个处理器下调度不同的线程执行</li></ul><p><strong>使用该策略实现线程的操作系统：</strong></p><ul><li>Windows XP&#x2F;2000</li><li>Solaris</li><li>Linux</li><li>Tru64 UNIX</li><li>Mac OS X</li></ul><h2 id="用户级线程和核心级线程的区别"><a href="#用户级线程和核心级线程的区别" class="headerlink" title="用户级线程和核心级线程的区别"></a>用户级线程和核心级线程的区别</h2><ol><li>线程的调度和切换时间：用户级线程的切换通常发生在同一应用进程下的线程之间，无需通过中断来进入OS的内核，而且切换策略也比较简单，因此其切换时间很快。而核心级线程的切换时间相对较慢。</li><li>系统调用：用户级线程在执行系统调用时，由于内核不知道线程的存在，只当做是进程的系统调用，所以会阻塞整个进程而切换到另一个进程，待系统调用执行完毕之后，才会继续执行原来进程。而在核心级线程中，线程是资源调度的基本单位，所以当一个线程执行系统调用时，内核仅仅阻塞该线程并且可以继续执行同一进程下的其他线程</li><li>线程执行时间：在用户级线程中，进程是执行的基本单位，而如果一个进程中设置了多个线程，那么平均分配到单个线程的执行时间就会减少。而在核心级线程中，单个线程是执行的基本单位，所以执行时间更多。</li></ol><h2 id="用户级线程和核心级线程的优缺点"><a href="#用户级线程和核心级线程的优缺点" class="headerlink" title="用户级线程和核心级线程的优缺点"></a>用户级线程和核心级线程的优缺点</h2><h3 id="用户级线程-1"><a href="#用户级线程-1" class="headerlink" title="用户级线程"></a>用户级线程</h3><p><strong>优点：</strong></p><ol><li>可以在不支持线程的操作系统中实现</li><li>创建和销毁线程、线程切换等线程的管理操作开销比内核线程少得多</li><li>允许每个进程定制自己的调度算法，线程管理更加灵活</li><li>线程的调度无序内核的参与，控制简单</li></ol><p><strong>缺点：</strong></p><ol><li>线程发生I&#x2F;O或者页面故障引发的阻塞时，整个进程也会阻塞</li><li>一个单独的进程内部没有时钟中断，所以不可能采用轮转调度的方法调度线程</li><li>多个处理器下，同一进程中的线程只能在一个处理器下分时复用</li></ol><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><p><strong>优点：</strong></p><ol><li>当有多个处理器时，同一进程的不同线程可以同时进行。</li><li>如果一个线程被阻塞，可以调度同一进程下的不同线程执行</li><li>所有能阻塞线程的的调用都以系统调用的形式实现</li></ol><p><strong>缺点：</strong></p><ol><li>代价大，性能较差</li></ol><h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><h3 id="Many-to-One模型"><a href="#Many-to-One模型" class="headerlink" title="Many-to-One模型"></a>Many-to-One模型</h3><p><strong>多个用户级线程映射到一个内核线程</strong></p><ul><li>线程管理由线程库在用户空间中执行，效率比较高</li><li>如果一个线程执行了阻塞系统调用，整个进程会被阻塞</li><li>任何时间下只有一个线程访问内核，并行性差（多核环境下）</li></ul><p>例子：</p><ul><li>Solaris Green Threads</li><li>GNU Portable Threads</li></ul><h3 id="One-to-One模型"><a href="#One-to-One模型" class="headerlink" title="One-to-One模型"></a>One-to-One模型</h3><p><strong>每个用户进程对应一个内核进程</strong></p><ul><li>并行性好</li><li>需要一一对应，资源开销大</li></ul><p>例子：</p><ul><li>Windows NT&#x2F;XP&#x2F;2000</li><li>Linux</li><li>Solaris 9 and later</li></ul><h3 id="Many-to-Many模型"><a href="#Many-to-Many模型" class="headerlink" title="Many-to-Many模型"></a>Many-to-Many模型</h3><p><strong>多个用户进程映射到多个内核进程</strong></p><ul><li>允许操作系统创建足够多的内核进程</li></ul><p>例子：</p><ul><li>Solaris prior to version 9</li><li>Windows NT&#x2F;2000 with the Threadfiber package</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2022/09/22/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/09/22/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h1><p><strong>并发：现代操作系统允许多个程序被加载入内存中并同时进行</strong></p><p>在单核CPU上，多个程序不可能在微观意义（纳秒级时间尺度）上同时进行，只能实现串行，但通过多道迅速来回切换执行不同程序，可以在宏观意义（秒级时间尺度）上同时进行。</p><p>假设有两个程序A、B执行时间均为40ms，如果他们轮流执行，总的执行时间为80ms，CPU的效率较低。而在两程序执行过程中，不可能每时每刻都在使用CPU，也会对其他设备进行使用，所以采用并发的方式执行多个程序可以有效地提高CPU的使用效率。</p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663843296075.png" alt="1663843296075"><img src="/./image/%E8%BF%9B%E7%A8%8B/1663843312802.png" alt="1663843312802"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>正在执行中的程序</li><li>一个具有一定独立性的程序在数据集合上的一次动态执行过程</li><li>系统进行资源分配和调度的基本单位</li></ul><p>进程是一个动态概念，程序是一个静态概念</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>结构特征：程序段、数据段、进程控制块PCB</li><li>动态性：最基本的特征，进程是动态产生、动态消亡的；进程在其生命周期内，有三种基本状态来切换（就绪、等待、执行）</li><li>并发性：任何进程都可以和其他进程一起向前推进</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位</li><li>异步性：每个进程都已其相对独立、不可预知的速度向前推进</li></ul><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><ul><li>代码段</li><li>数据段</li><li>堆</li><li>堆栈</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663844353578.png" alt="1663844353578"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p><strong>进程树：</strong></p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663844992620.png" alt="1663844992620"></p><h2 id="进程层次"><a href="#进程层次" class="headerlink" title="进程层次"></a>进程层次</h2><ul><li>在Unix操作系统中，所有的进程都由其他的进程生成，生成与被生成的进程为父子关系。</li><li>在上图所示的进程树中，init进程是所有用户进程的祖先进程。</li><li>在Windows系统下，进程之间都是平等的。</li></ul><h2 id="程序控制块（PCB）"><a href="#程序控制块（PCB）" class="headerlink" title="程序控制块（PCB）"></a>程序控制块（PCB）</h2><p><strong>PCB用于保存进程在执行过程中的重要信息，进程与PCB是一一对应的</strong></p><ul><li>进程存在的唯一标识</li><li>存储着OS所需的用于描述进程和控制进程的所有信息</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663845626478.png" alt="1663845626478"></p><p><strong>进程空间和大小</strong></p><ul><li>每个PCB都要占据一定的内存，PCB存贮在Process table中。</li><li>Process table的大小有限，所存储的PCB数量有限，所以并发进行的进程数有限</li></ul><h2 id="CPU在不同进程中的切换"><a href="#CPU在不同进程中的切换" class="headerlink" title="CPU在不同进程中的切换"></a>CPU在不同进程中的切换</h2><ul><li>当CPU切换到另一个进程时，需要保存老进程的状态，并且加载新系统的状态</li><li>不同进程的切换时额外的时间开销，在切换过程中CPU不会进行任何有效的工作</li><li>切换时间与硬件性能密切相关</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663846217100.png" alt="1663846217100"></p><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p><strong>在进程执行时，它的状态会发生多次变化：</strong></p><ul><li>new：进程刚被创建</li><li>running：进程正在执行</li><li>blocked：进程等待某些资源就绪后才能执行</li><li>ready：进程所需资源准备完毕，等待CPU分配时间</li><li>terminated：进程终止、</li></ul><p><strong>进程在以下情况下会被生成：</strong></p><ul><li>系统初始化</li><li>正在运行的进程调用系统生成子进程</li><li>用户命令生成进程</li><li>批处理作业的生成</li></ul><p>进程的状态切换：</p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663849046495.png" alt="1663849046495"></p><ul><li>Running：进程具有所需资源并正在CPU中运行</li><li>Ready：进程具有所需资源但正在等待CPU的分配</li><li>Blocked：进程不具备所需资源</li><li>1：进程在Running过程中发现所需资源不足，于是转入Blocked态</li><li>2：进程在Running过程中CPU所分配的时间耗尽，转入Ready态</li><li>3：进程得到CPU分配的时间，转入Running态</li><li>4：进程获得了执行所需资源，转入Ready态（只能被其他进程唤醒而不能自己转变）</li></ul><p><em>实际上，由于Running态和Ready态都具备运行所需的资源，所以将它们统称为Runnable态，并将它们储存在同一队列中。存在Scheduler指针，指向正在运行的进程，并以指针的变化来表示Running态和Ready态的变化。</em></p><p>进程的终止：</p><ul><li>进程在完成时自己终止</li><li>进程在碰见错误时终止</li><li>进程在收到其他进程的特定信号时终止</li></ul><p><em>当进程自己终止时它进入“僵尸”态</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux-Unix的基本命令(2)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/</url>
      
        <content type="html"><![CDATA[<p><strong>文件和目录基本操作命令</strong></p><h2 id="Shell命令特点"><a href="#Shell命令特点" class="headerlink" title="Shell命令特点"></a>Shell命令特点</h2><ul><li>Shell具有命令补齐（Command-Line Completion）的功能，它是指在键入的字符足以确定唯一一个文件时，按下 <code>&lt;Tab&gt;</code>键系统就会自动补齐该文件名的剩下部分。<br>例如：当键入 <code>&lt;[root@redflag /root] # hist&gt; </code>时，按下 <code>&lt;Tab&gt;</code>系统将会自动补齐 <code>&lt;[root@redflag /root] # history&gt;</code></li><li>Linux的命令区分大小写，且通常Linux的命令是小写的</li></ul><h2 id="ls命令-List-directory-contents"><a href="#ls命令-List-directory-contents" class="headerlink" title="ls命令-List directory contents"></a>ls命令-List directory contents</h2><ul><li>语法：ls[参数]文件名或路径</li><li>功能：列出文件或者子目录的信息</li><li>参数：<br><code>&lt;-a&gt;</code>：显示所有文件，包括以.开头的隐藏文件<br><code>&lt;-l&gt;</code>：以长格式显示文件或子目录的信息<br><code>&lt;-i&gt;</code>：显示每个文件的索引号<br><code>&lt;-R&gt;</code>：显示目录及下级子目录结构<br><code>&lt;-S&gt;</code>：以文件大小排序</li><li>ls -l以长格式显示文件或子目录的信息，如：<br><em>drwxr-xr-x 2 jjpr1 group 512 Nov 18 10：24</em><br><em>drwxrwxr-x 24 root auth 512 Nov 16 10：33</em></li><li>用颜色代表不同文件：<br>蓝色：目录<br>绿色：可执行文件<br>红色：压缩文件<br>浅蓝色：链接文件<br>灰色：其他文件</li><li>在ls -l显示结果中，第一个字符表示文件的类型：<br><code>&lt;d&gt;</code>：目录<br><code>&lt;-&gt;</code>：普通文件<br><code>&lt;c&gt;</code>：字符文件<br><code>&lt;b&gt;</code>：块设备<br><code>&lt;l&gt;</code>：链接文件</li><li>pwd - 打印用户当前所处目录</li><li>cd目录 - 改变当前目录</li></ul><h2 id="mkdir命令-make-directories-建立目录"><a href="#mkdir命令-make-directories-建立目录" class="headerlink" title="mkdir命令 - make directories 建立目录"></a>mkdir命令 - make directories 建立目录</h2><ul><li>语法：mkdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：当父目录不存在时，可将其连同子目录一起创建，即一次可建立多级目录<br><code>&lt;mkdir -p dir2/bak&gt;</code>：在dir2目录下建立子目录bak，如果dir2不存在则将它一同创立，在dir2目录事先存在时等同于 <code>&lt;mkdir dir2/bak&gt;</code></li></ul><h2 id="rmdir命令-remove-directories-删除目录"><a href="#rmdir命令-remove-directories-删除目录" class="headerlink" title="rmdir命令 - remove directories 删除目录"></a>rmdir命令 - remove directories 删除目录</h2><ul><li>语法：rmdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：一起删除父目录时父目录下应无其他目录<br><code>&lt;rmdir test&gt;</code>：删除当前目录下的test目录，被删除的test目录下应无其他文件或目录<br><code>&lt;rmdir -p longkey/test&gt;</code>：若longkey目录下除test外无其他目录或文件，则将它一同删除</li></ul><h2 id="cp命令-copy-files-复制文件"><a href="#cp命令-copy-files-复制文件" class="headerlink" title="cp命令 - copy files 复制文件"></a>cp命令 - copy files 复制文件</h2><ul><li>语法：cp [options] sourcefile destfile<br>cp [options] sourcefile … directory</li><li>作用：将一文件复制为另一文件，或是将多个文件复制到指定目录下</li><li>参数选项：<br><code>&lt;-p&gt;</code>：保持原始文件属性<br><code>&lt;-f&gt;</code>：如果目标文件已经存在，则覆盖它<br><code>&lt;-i&gt;</code>：提示是否要覆盖已有的目标文件<br><code>&lt;-r R&gt;</code>：递归复制目录，包括目录下的各级子目录。</li><li>目的目录不能在原目录下。如 <code>&lt;cp -r //targetdir&gt;</code>，会使系统进入死循环甚至瘫痪。<br><code>&lt;$ cp aaa bbb&gt;</code>：将文件aaa（已存在）复制并命名为bbb<br><code>&lt;$ cp *.c Finished&gt;</code>：将所有.c文件拷贝到Finished目录下</li></ul><h2 id="rm命令-remove-删除文件或目录"><a href="#rm命令-remove-删除文件或目录" class="headerlink" title="rm命令 - remove 删除文件或目录"></a>rm命令 - remove 删除文件或目录</h2><ul><li>语法：rm [-firR] file&#x2F;directory</li><li>参数选项：<br><code>&lt;-f&gt;</code>：不加提示的删除已存在的文件<br><code>&lt;-i&gt;</code>：交互删除<br><code>&lt;-r&gt;</code>：递归删除整个目录</li><li><code>&lt;rm -i *.c&gt;</code>：删除所有.c文件，并在删除前加以询问<br><code>&lt;rm -r finish&gt;</code>：删除finish目录下的所有文件和子目录</li></ul><h2 id="mv命令-move-移动文件或目录"><a href="#mv命令-move-移动文件或目录" class="headerlink" title="mv命令 - move 移动文件或目录"></a>mv命令 - move 移动文件或目录</h2><ul><li>语法：mv [-fi] source_file … target_directory<br>mv [-fi] source_file target_file</li><li>作用：将文件移动到指定目录下或将文件重命名</li><li>参数选项：<br><code>&lt;-f&gt;</code>：禁止提示<br><code>&lt;-i&gt;</code>：文件或目录重名时提示是否覆盖</li></ul><h2 id="tough命令-生成空文件或者修改文件的存取或修改时间"><a href="#tough命令-生成空文件或者修改文件的存取或修改时间" class="headerlink" title="tough命令 - 生成空文件或者修改文件的存取或修改时间"></a>tough命令 - 生成空文件或者修改文件的存取或修改时间</h2><ul><li>语法：tough [参数] 文件或者目录名</li><li>实例：</li><li><code>&lt;tough *&gt;</code> ：将当前目录下所有文件时间修改为当前系统时间<br><code>&lt;tough -d 20050912 test&gt;</code>：将文件test的时间修改为20050912<br><code>&lt;tough aaa&gt;</code>：如果aaa文件存在则将其修改为当前系统时间，如果不存在则创建文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux/Unix的基本命令(1)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>系统的登录、退出、启动和关闭</strong></p><ol><li>Linux是一个多用户的操作系统，注册用户想要使用Linux系统资源，必须登陆系统。</li><li>Linux将用户分为普通用户和超级用户。一般的Linux使用者均为普通用户，而系统管理员使用超级用户来进行文件管理等工作。</li><li>用户身份不同系统提示符也不同。<br>#：超级用户<br>$：普通用户</li></ol><h2 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h2><ol><li><p>系统启动后，输入用户名并键入回车符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login：root</span><br></pre></td></tr></table></figure></li><li><p>输入用户口令，输入的口令不会显示。如果输入错误，屏幕上会显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Login incorrect</span><br><span class="line">Login：</span><br></pre></td></tr></table></figure></li></ol><p>执行上述两步后，若屏幕显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loclhost root] #</span><br></pre></td></tr></table></figure><p>说明登录成功，可以进行操作</p><h2 id="系统退出"><a href="#系统退出" class="headerlink" title="系统退出"></a>系统退出</h2><p>用户在使用完成后退出系统的操作叫做注销，方法有三种：</p><ol><li>键入：exit</li><li>按Ctrl + D</li><li>logout</li></ol><h2 id="系统的启动与关闭"><a href="#系统的启动与关闭" class="headerlink" title="系统的启动与关闭"></a>系统的启动与关闭</h2><p>Linux在不使用系统资源时，需要关闭系统。必须由超级用户在shell提示符下，键入关闭命令，系统将完整的执行关闭所有进程，释放占用资源，停止运行。切断电源。</p><h3 id="关闭系统的命令："><a href="#关闭系统的命令：" class="headerlink" title="关闭系统的命令："></a>关闭系统的命令：</h3><p><code>[root@loclhost /root] # shutdown -h now</code></p><p><code>[root@loclhost /root] # halt</code></p><p><code>[root@loclhost /root] # init 0</code></p><p><code>[root@loclhost /root] # poweroff</code></p><h3 id="重启系统的命令："><a href="#重启系统的命令：" class="headerlink" title="重启系统的命令："></a>重启系统的命令：</h3><p>reboot 命令</p><p>shutdown -r <code>&lt;time&gt;</code> 命令</p><p>组合键Ctrl + Alt + Del</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/13/post1/"/>
      <url>/2022/09/13/post1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机是如何启动（boot）的？"><a href="#计算机是如何启动（boot）的？" class="headerlink" title="计算机是如何启动（boot）的？"></a>计算机是如何启动（boot）的？</h1><p><strong>计算机的启动分为四个阶段</strong></p><h2 id="第一阶段：BIOS（Basic-Input-x2F-Output-System）"><a href="#第一阶段：BIOS（Basic-Input-x2F-Output-System）" class="headerlink" title="第一阶段：BIOS（Basic Input&#x2F;Output System）"></a>第一阶段：BIOS（Basic Input&#x2F;Output System）</h2><ul><li>硬件自检：首先检查计算机硬件是否能够满足计算机运行的基本需求（Power-On Self-Test）</li><li>启动顺序：在BIOS完成对硬件的自检之后，会将控制权转交给下一阶段的启动程序，这时BIOS需要知道下一阶段的启动程序储存在何处，因此BIOS需要一个关于外部储存设备的排序，排在前面的设备优先转交控制权。这种排序被称为启动顺序（Boot Sequence）</li></ul><h2 id="第二阶段：主引导顺序"><a href="#第二阶段：主引导顺序" class="headerlink" title="第二阶段：主引导顺序"></a>第二阶段：主引导顺序</h2><ul><li>BIOS根据启动顺序将控制权转交给对应的外部储存设备。即根据用户指定的引导顺序从硬盘、软盘或是可移动设备中读取启动设备的MBR（Master Boot Recort），并放入指定内存位置0x7c00。</li></ul><p><strong>分区表：</strong></p><p>计算机读取该设备的第一个扇区，即该设备的前512个字节，来得到启动程序的具体位置。</p><p>如果该设备的第一个扇区最后两个字节是0x55和0xAA（二进制分别是01010101和10101010，0和1交替做识别码），则该设备储存了正确的启动程序；反之则需要将控制权按启动顺序转交给下一存储设备。<br><img src="/./post1/20220913211755.png"></p><h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><ul><li>计算机的控制权转交给硬盘的某个分区</li><li>该分区的第一个扇区被激活，叫主引导扇区（Volume boot record），用于告诉计算机操作系统在这个分区中的位置。然后计算机就会把操作系统加载到内存中。</li></ul><p><em>当计算机中存在多种操作系统时，计算机读取主引导扇区的前446字节的机械码之后，不会将控制权直接转交某一分区，而是启动事先安装的启动管理器（Boot Loader）,由用户选择使用哪一个操作系统。</em></p><p><img src="/./post1/20220913211814.png"></p><h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><ul><li>控制权转交操作系统之后，操作系统的内核首先被加载入内存中。</li><li>以Linux系统为例，先载入&#x2F;boot目录下的是kernel。</li><li>内核加载完毕后，第一个运行的程序是&#x2F;sbin&#x2F;init，他根据配置文件生成init进程。这是Linux系统启动后生成的第一个进程，pid进程编号为1，其他进程都是他的后代。</li><li>然后init进程加载系统的各个模块，例如窗口模块和网络模块，直到执行&#x2F;bin&#x2F;login程序，跳出登入界面，等待用户输入账号和密码。</li></ul><h1 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h1><h2 id="OS的目标"><a href="#OS的目标" class="headerlink" title="OS的目标"></a>OS的目标</h2><ul><li>提高系统资源的利用率：使计算机资源更好更充分的被用户利用</li><li>提高系统效率：效率的提高可以缩短完成每项任务的时间，提高<em>系统吞吐量</em></li><li>方便性：方便使用</li><li>可扩充性：系统功能的改变和结构的扩充不影响原有功能的使用</li><li>开放性：不同的计算机和设备能够被集成起来有效使用</li></ul><h2 id="推动操作系统发展的因素"><a href="#推动操作系统发展的因素" class="headerlink" title="推动操作系统发展的因素"></a>推动操作系统发展的因素</h2><ul><li>计算机硬件升级和新的硬件类型发展</li><li>用户需求扩大</li><li>计算机体系结构的不断发展</li><li>市场的激烈竞争，OS功能的不断完善</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
