<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>竞争条件</title>
      <link href="/2022/10/09/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
      <url>/2022/10/09/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h1><p>当我们需要打印某一文件时，目的文件会进入打印机队列。假设负责将目的文件1进入队列的进程在此时用完了CPU时间片，文件1尚未进入队列但已经获取到了目的地址。之后目的文件2进入队列同一位置，当前一进程恢复时，文件依然进入之前位置，就会造成文件2被覆盖。这时它们之间就产生了竞争。</p><h2 id="避免进行竞争的条件"><a href="#避免进行竞争的条件" class="headerlink" title="避免进行竞争的条件"></a>避免进行竞争的条件</h2><ul><li>任意两进程不能同时进入临界区</li><li>不能假设进程运行速度或是CPU使用的数量</li><li>在临界区外运行的进程不会阻止其他进程进入临界区</li><li>任意一个进程不能被长期无休止的阻碍在临界区之外</li></ul><p><em>临界区不是某一段关键的内存或是CPU资源，而是能调用这些资源的关键代码</em></p><h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><h3 id="进程或线程之间存在的关系"><a href="#进程或线程之间存在的关系" class="headerlink" title="进程或线程之间存在的关系"></a>进程或线程之间存在的关系</h3><ol><li>互斥：进线程共享同一资源，轮流使用该资源并且只有具有使用权的才能运行</li><li>同步：B进程只有获得A进程执行完毕产生的资源才能继续运行</li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>忙等待：进程不断地检测共享资源是否可用</li><li>睡眠与唤醒：当进程检测到资源不可用时，进入睡眠态，当资源可用时，进程被唤醒</li></ul><h3 id="加锁法"><a href="#加锁法" class="headerlink" title="加锁法"></a>加锁法</h3><p>设一变量lock</p><p>当资源可用时，lock值为0，当资源不可用时，lock值为1</p><p>进入临界区前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(lock != 0);</span><br><span class="line">lock = 1;</span><br></pre></td></tr></table></figure><p>离开临界区时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock = 0;</span><br></pre></td></tr></table></figure><p>存在严重的竞争条件：</p><ul><li>while循环不断检测lock是否等于0，占用了过多的CPU资源</li><li>假设进程A检测到lock&#x3D;0，但是它的时间片使用完了，轮到进程B运行并进入临界区。当进程A恢复时它不需要检测lock值就能进入临界区，这样就会造成由两个进程存在于临界区的严重情况</li></ul><h3 id="TSL-Test-and-Set-Lock"><a href="#TSL-Test-and-Set-Lock" class="headerlink" title="TSL(Test and Set Lock)"></a>TSL(Test and Set Lock)</h3><p>针对加锁法可能存在的问题，我们有TSL算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">TSL REGISTER,LOCK//copy lock to register and set lock to 1</span><br><span class="line">CMP REGISTER,#0//was lock 0?</span><br><span class="line">JNE enter_region//if it was nozero,lock was set,so loop</span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">MOVE LOCK,#0//store 0 in lock</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>在将lock值置为1时，用寄存器储存原来的lock值并对其进行判定，若为不为零则继续循环。</p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>分类：</p><ul><li>非记录型信号量</li><li>记录型信号量</li><li>二元信号量</li></ul><h2 id="非记录型信号量"><a href="#非记录型信号量" class="headerlink" title="非记录型信号量"></a>非记录型信号量</h2><ul><li>对应忙等待方式</li><li>包含一个非负整数</li><li>整数的含义：<br>非零整数：可用的资源数<br>0：无可用资源</li></ul><h2 id="PV原语和信号量"><a href="#PV原语和信号量" class="headerlink" title="PV原语和信号量"></a>PV原语和信号量</h2><p><strong>原语：执行快速且不可被阻断的语句</strong></p><p>PV原语：PV来自荷兰语中的proberen（测试）和verhogen（增量），也可以称作down&#x2F;up或是wait&#x2F;signal操作</p><p>除了初始化，只有在原语中才能使用信号量（仅仅是读取都不行）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P(Semaphore s)&#123;</span><br><span class="line">while(!s&gt;0)</span><br><span class="line">yield the CPU;</span><br><span class="line">s--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(Semaphore s)&#123;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以前文中打印机程序举例，初始时可用资源为1，当有程序进入时，s–，s被置为0。此时之后想要进入的程序只能不断执行while循环，检测s是否大于零。当程序退出时，执行V原语，s被置为1。由于各程序对s的检测是轮流的，所以有且仅有一个程序能检测到s为1并执行P原语。</p><h2 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h2><p><strong>如果某资源只有一个，在忙等待情况下，信号量只会是0和1中的一个，这时的信号量被称为二元信号量</strong></p><p>注意取值的含义：</p><ul><li>1代表有资源可用</li><li>0代表无资源可用</li><li>这与一般的lock方法相反</li></ul><h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><ul><li>对应睡眠与唤醒方式</li><li>包含一个整数和一个等待队列</li><li>数值的含义：<br>正整数：可用的资源数量<br>0：无可用资源<br>负整数：处于等待队列中的进程的个数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P(Semaphore s)&#123;</span><br><span class="line">s = s - 1;</span><br><span class="line">if(s &lt; 0)&#123;</span><br><span class="line">add to the semaphore&#x27;s queue and sleep.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(Semaphore s)&#123;</span><br><span class="line">s++;</span><br><span class="line">if(s &lt;= 0)&#123;</span><br><span class="line">wakeup a waiting process inthe semaphore&#x27;s queue.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有三个文件a，b，c需要被打印，a先运行，P原语运行，s被置为0。b进入，P原语运行，s被置为-1，b进入等待队列。c进入，P原语运行，s被置为-2，c进入等待队列。a打印完成，V原语运行，s被置为-1，b被唤醒。b打印完成，V原语运行，s被置为0，c被唤醒。c打印完成，V原语运行，s被置为1，恢复正常。</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>存在这样一个模型，一个自产自销的面包店，店里最多能储存N个面包，面包的销售和生产不能同时进行，当面包存储N个之后，生产不能再进行，只剩0个之后，销售不能再进行，我们把N个储存单位叫做缓冲区。</p><p>有两种算法能够解决这个问题</p><h3 id="存在严重竞争问题的解法"><a href="#存在严重竞争问题的解法" class="headerlink" title="存在严重竞争问题的解法"></a>存在严重竞争问题的解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100;</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">item = produce_item();</span><br><span class="line"><span class="keyword">if</span>(count == N)</span><br><span class="line">sleep();</span><br><span class="line">insert_item(item);<span class="comment">//如果缓冲区面包不为N，就把新生产的面包插入缓冲区</span></span><br><span class="line">count = count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">1</span>)<span class="comment">//若刚刚count等于零，有可能是consumer消耗为零，此时consumer转入睡眠态，需要被唤醒</span></span><br><span class="line">wakeup_consumer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">sleep();</span><br><span class="line">item = remove_item();</span><br><span class="line">count = count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(count == N - <span class="number">1</span>)</span><br><span class="line">wakeup_consumer();</span><br><span class="line">consumer_item(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法存在着严重的错误，假设消费者最先运行，当它执行完毕<strong>count&#x3D;0</strong>的判断之后，如果它的时间片耗尽，消费者尚未进入睡眠态就被打断，如果调度程序正好运行生产者进程，count成功加1。因为消费者并未进入睡眠态，所以对它的唤醒操作无效。生产者一直生产至count&#x3D;N之后再进入睡眠态，而消费者恢复运行之后它进入睡眠态，此时生产者与消费者均处在睡眠态，系统锁死。</p><h3 id="使用信号量的解决办法"><a href="#使用信号量的解决办法" class="headerlink" title="使用信号量的解决办法"></a>使用信号量的解决办法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100;</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量</span></span><br><span class="line">semaphore empty = N;<span class="comment">//空格子个数</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//满格子个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">item = produce_item();</span><br><span class="line">P(empty);<span class="comment">//占用一个空格子，不成功就转入阻塞态</span></span><br><span class="line"> P(mutex);<span class="comment">//取得缓冲区控制权</span></span><br><span class="line">insert_item(item);</span><br><span class="line">V(mutex);<span class="comment">//放弃缓冲区控制权</span></span><br><span class="line">V(full);<span class="comment">//产生一个满格子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">item = remove_item();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">consumer_item(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutex信号量解决互斥问题，empty、full信号量解决同步问题。</p><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>假设存在五个哲学家，吃五碗面，在每碗面间隔中有一只筷子，只有拿到左右两只筷子后才能开吃。</p><h3 id="不正确的解法"><a href="#不正确的解法" class="headerlink" title="不正确的解法"></a>不正确的解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define N 5</span><br><span class="line"></span><br><span class="line">void Philosophier(int i)&#123;</span><br><span class="line">while(TRUE)&#123;</span><br><span class="line">think();</span><br><span class="line">take_chopstick(i);//拿起左手筷子</span><br><span class="line">take_chopstick((i + 1) % N);//拿起右手筷子</span><br><span class="line">eat();</span><br><span class="line">put_chopstick(i);</span><br><span class="line">put_chopstick((i + 1) % N);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法在五个哲学家都进入饥饿状态时，五个哲学家都只能拿起左手筷子而吃不了面，进入死锁状态。</p><h3 id="使用信号量的解决办法-1"><a href="#使用信号量的解决办法-1" class="headerlink" title="使用信号量的解决办法"></a>使用信号量的解决办法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1) % N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATTING 2</span></span><br><span class="line"><span class="type">int</span> state[N];<span class="comment">//每个哲学家所处的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量，保护全局变量state数组</span></span><br><span class="line">semaphore s[N];<span class="comment">//代表五个哲学家能否吃面,初值为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATTING &amp;&amp; state[RIGHT] != EATTING)&#123;</span><br><span class="line">state[i] = EATTING;</span><br><span class="line">V[s[i]];<span class="comment">//发放通行证，哲学家i可以吃面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_chopstick</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">state[i] = HUNGRY;</span><br><span class="line">test(i);</span><br><span class="line">V(mutex);</span><br><span class="line">P(s[i]);<span class="comment">//检测i的通行证，如果没有，程序暂停</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_chopstick</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">state[i] = THINKING;</span><br><span class="line">test(LEFT);</span><br><span class="line">test(RIGHT);<span class="comment">//检测左右邻在自己结束吃面后能否开始吃面</span></span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">phisolophier</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">think();</span><br><span class="line">take_chopstick(i);</span><br><span class="line">eat();</span><br><span class="line">put_chopstick(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>ps：当我们创建一个全局变量时，需要对应的创建一个防互斥信号量以防止因多个对缓冲区的访问造成不必要的问题</em></p><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><p>假设存在多个读者与多个写者，多个读者可以同时访问数据，而在任意时刻只有一个写者能访问数据。</p><h3 id="读者优先解法"><a href="#读者优先解法" class="headerlink" title="读者优先解法"></a>读者优先解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore fmutex = <span class="number">1</span>;<span class="comment">//保护数据</span></span><br><span class="line">semaphone rdcntmutex = <span class="number">1</span>;<span class="comment">//保护读者数变量</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">P(rdcntmutex);</span><br><span class="line"><span class="keyword">if</span>(reader_count == <span class="number">0</span>)&#123;</span><br><span class="line">P(fmutex);<span class="comment">//和写者争抢文件访问权</span></span><br><span class="line">&#125;</span><br><span class="line">read_count++;</span><br><span class="line">V(rdcntmutex);</span><br><span class="line"><span class="comment">//Do reading operation</span></span><br><span class="line">P(rdcntmutex);</span><br><span class="line">reader_count--;</span><br><span class="line"><span class="keyword">if</span>(reader_count == <span class="number">0</span>)&#123;</span><br><span class="line">V(fmutex);<span class="comment">//释放对文件的访问权</span></span><br><span class="line">&#125;</span><br><span class="line">V(rdcntmutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">P(fmutex);</span><br><span class="line"><span class="comment">//Do writing operation</span></span><br><span class="line">V(fmutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/10/03/%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/10/03/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>排序算法中较为常用的有：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序等，而他们的时间复杂度也各自不同，主要有：O(n^2),O(nlogn),O(n)等。我们将依照不同的时间复杂度来分别介绍这些算法。</p><h1 id="如何评价排序算法"><a href="#如何评价排序算法" class="headerlink" title="如何评价排序算法"></a>如何评价排序算法</h1><p>在了解具体的排序算法之前，我们需要知道如何评价一个算法是否高效，一般从以下几点来衡量：</p><h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><ol><li>最好情况、最坏情况、平均情况下的时间复杂度</li><li>时间复杂度的常数、系数、低阶</li><li>比较次数和交换（或移动）次数</li></ol><h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量，空间复杂度为O(1)的排序算法我们称为原地排序</p><h2 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标：</p><p><strong>稳定性  如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</strong></p><h1 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调度算法</title>
      <link href="/2022/10/01/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/01/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="调度算法概述"><a href="#调度算法概述" class="headerlink" title="调度算法概述"></a>调度算法概述</h1><h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><p>长期调度（作业调度）：系统选择一个进程进入内存中的就绪队列中。</p><ul><li>存在于批处理系统中，被选中的程序通常不会马上被执行，而是被放到存储设备的缓冲池中，待系统状态就绪之后，由长期调度的系统程序把进程调度到系统中准备运行</li></ul><p>短期调度（CPU调度）：从就绪队列中选择一个进程，并为之分配CPU</p><p><strong>二者的区别：</strong></p><ul><li>长期调度多用于批处理系统（用户一次性提交一批任务，系统在完成后响应），而短期调度多用于交互式计算机系统（用户每提交一个任务，系统立刻反应）</li><li>长期调度需要大量准备来载入一个新的进程，短期调度效率更高，只需将进程由就绪态变为运行态</li></ul><h2 id="短期调度（CPU调度）"><a href="#短期调度（CPU调度）" class="headerlink" title="短期调度（CPU调度）"></a>短期调度（CPU调度）</h2><p>进程的执行周期由CPU执行周期和I&#x2F;O等待周期（将运行数据写入硬盘或从硬盘上读取下一个运行的进程）组成，由于实际进程执行的过程中CPU执行一段时间后就需要I&#x2F;O设备进行进一步的准备，所以采用短期调度的方式来分配CPU时间片能大大提高CPU的利用效率。</p><h3 id="CPU调度器"><a href="#CPU调度器" class="headerlink" title="CPU调度器"></a>CPU调度器</h3><p>CPU调度器的作用是在分配给一个进程的时间片耗尽之后，抢夺回CPU的控制权并将它分配给其他的进程，或者是以下情况：</p><ol><li>当一个进程由运行态转变为就绪态</li><li>当一个进程发生中断时</li><li>当I&#x2F;O完成时</li><li>当进程终止时</li></ol><p>前者称为抢占调度，后者称为非抢占调度</p><h3 id="分派程序"><a href="#分派程序" class="headerlink" title="分派程序"></a>分派程序</h3><p>将CPU控制转交给短期调度程序选择的进程，包括：</p><ul><li>上下文切换</li><li>切换到用户程序</li><li>跳转到用户程序的合适位置以重新运行程序</li></ul><p><strong>分派延时：进程停止一个而转换到另一个所需时间</strong></p><h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><p>我们需要多个算法来评价一个调度算法，例如：</p><ul><li>CPU利用率</li><li>吞吐量：一个时间单元内所完成的进程数</li><li>周转时间：从一个进程提交到完成的时间<br>等待时间：进程在就绪队列中所花的时间<br>运行时间：进程在运行态的时间</li><li>响应时间：从提交申请到系统第一次响应的时间（用来描述交互式计算机系统）</li></ul><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ol><li>先来先服务：只考虑每个作业的等待时间</li><li>最短作业优先：只考虑每个作业的执行时间</li><li>最高响应比：响应比R&#x3D;1+W&#x2F;T</li><li>轮转法：等待时间与执行时间成比例。时间片长度Q值的选择</li><li>多级反馈轮转法：划分不同队列，给予不同的优先级和时间片</li><li>优先级法：静态优先级，动态优先级</li></ol><p>前三者多用于批处理系统，后三者多用于交互式计算机系统</p><h1 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h1><p>假设存在三个进程P1、P2、P3，他们的区间时间分别为24、3、3</p><p>如果按照先来先服务的调度算法，它们的等待时间分别为0、24、27，平均等待时间为17</p><p>而如果按P2、P3、P1的顺序分配，那么他们的等待时间分别为0、3、6，平均等待时间为3，大大降低。这就是先来先服务算法的缺点：护航效应</p><p>护航效应：当长进程排在短进程之前时，所有进程都在等待一个大进程释放CPU，导致CPU和设备的效率变低</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>周转时间和响应时间无法保证</li><li>对短作业不利</li></ol><p>对于那些执行时间较短的作业或进程来说，如果他们在执行时间很长的作业或进程之后进行，那么他们的等待时间将会很长。</p><p><strong>在实际操作系统中，虽然很少单独使用FCFS算法，但和其他的一些算法结合起来，FCFS算法使用的还是相当多的。</strong></p><h1 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h1><p><strong>将每个进程与下一个CPU区间段相关联，分配CPU给具有最短区间段的进程</strong></p><p>短作业优先调度算法又分为两种：</p><ul><li>非抢占式——CPU一旦分配给了进程就不能再被抢占，直到进程的CPU时间片耗尽。</li><li>抢占式——如果有一个CPU区间段小于当前执行进程的新进程进入就绪态，立即停止当前运行的进程并将CPU分配给更短的进程。</li></ul><p>假设有进程p1、p2、p3、p4，到达时间分别为0、2、4、5，区间时间为7、4、1、4。</p><h2 id="短作业-x2F-进程优先（SJF）"><a href="#短作业-x2F-进程优先（SJF）" class="headerlink" title="短作业&#x2F;进程优先（SJF）"></a>短作业&#x2F;进程优先（SJF）</h2><p>在非抢占式调度算法下，他们的执行顺序为：p1、p3、p2、p4。等待时间为0、6、3、7。平均等待时间为4。</p><p>优点：SJF对短作业有利，并且整体性能获得了提高</p><p>缺点：</p><ul><li>SJF需要提前知道或者至少需要估计每个作业所需的处理机时间</li><li>只要不断地有短作业进入系统，就有可能使长作业因得不到运行而“饿死”</li><li>SJF偏向短作业，不利于分时系统（由于不可抢占性）</li></ul><h2 id="最短剩余时间（SRT）"><a href="#最短剩余时间（SRT）" class="headerlink" title="最短剩余时间（SRT）"></a>最短剩余时间（SRT）</h2><p>而在抢占式调度算法下，他们的执行顺序为p1（2）、p2（2）、p3、p2（2）、p4、p1（5）。平均等待时间是（9+1+0+2）&#x2F;4&#x3D;3。</p><p>SRT是SJF增加了抢占机制的一种调度算法，它总是选择预期剩余时间最短的进程。只要新进程就绪，只要它的剩余时间小于当前执行进程的剩余时间，调度程序就有可能抢占当前正在运行的进程</p><p>优点：</p><ul><li>SRT不像FCFS偏向长进程，也不像轮转法会产生额外中断，从而减小了开销</li><li>从周转时间看，SRT比SJF有更好的性能</li></ul><p>缺点：必须记录之前的服务时间，从而增加了开销</p><h1 id="最高响应比（HRP）"><a href="#最高响应比（HRP）" class="headerlink" title="最高响应比（HRP）"></a>最高响应比（HRP）</h1><p>FCFS强调在系统的等待时间，SJF强调运行的时间，因此考虑一下比值：</p><p>R&#x3D;1+W&#x2F;T；</p><p>式中既考虑了在系统中的等待时间W，又考虑了运行时间T，综合了FCFS和SJF各自的特点。在进行进程调度时，选择响应比高者的进程投入运行。</p><h1 id="轮转法（RR）"><a href="#轮转法（RR）" class="headerlink" title="轮转法（RR）"></a>轮转法（RR）</h1><p>每个进程被赋予了一小段CPU时间（通常在10到100毫秒），当时间片用完之后CPU就会被抢占，之前运行的进程被加到就绪态队列的最后。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol><li>当一个进程用完了分配给它的时间片但未完成任务，那么他就会自行释放CPU并且移动到就绪队列尾部，等待下一次调度</li><li>同时调度程序会选择当前就绪序列中的第一个进程</li></ol><h2 id="调度契机"><a href="#调度契机" class="headerlink" title="调度契机"></a>调度契机</h2><ol><li>进程完成：调度另一个进程进行</li><li>进程未完成：进程的执行被时钟中断，排到就绪队列尾部，调度另一进程执行</li><li>被I&#x2F;O等原因阻塞：排在阻塞队列中，调度另一个进程。当被解封后，进程的PCB表从阻塞队列中摘下，进入就绪队列队尾。</li></ol><h2 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h2><p>假设就绪队列中有n个进程，分给每个进程的时间片为p，那么进程最长的等待时间为（n-1）q。</p><p>轮转法是一种基于时钟的抢占策略，以一个时间周期产生的时间中断调度各个进程的执行。当时间中断发生时，当前正在运行的进程被置于就绪队列中，然后再基于FCFS策略调度选择就绪进程来执行。它主要被用于分时系统中。轮转法设计的主要问题是时间片的长度q，一般有：</p><p><strong>T&#x3D;q * n</strong></p><ul><li>系统响应时间T：在进程个数一定时，系统响应时间正比于CPU时间片长度q。</li><li>就绪队列进程数目n：当系统要求的响应时间一定时，n反比于CPU时间片长度q</li><li>CPU时间片q：当CPU运行速度越快，q越短</li></ul><p><strong>CPU的执行时间&#x3D;进程的执行时间+系统开销</strong></p><p>时间片q过短，进程来回切换频繁，系统开销就会很大</p><p>时间片q过长，如果时间片足够就绪队列中最长的进程完成任务，进程就相当于是先来先服务算法。</p><p>改进方法：</p><ul><li>在不同的工作时段根据队列中不同的进程数来调整时间片</li><li>根据进程优先级的不同给予不同的时间片，通常优先级较高的进程给予较短时间片，优先级较低的给予较长时间片。</li></ul><h1 id="优先级调度（PS）"><a href="#优先级调度（PS）" class="headerlink" title="优先级调度（PS）"></a>优先级调度（PS）</h1><p>每个进程都会有一个优先级数，CPU被分配给具有最高优先级的进程（通常是优先级数最小的）。</p><p>SJF也是一种优先级调度，优先级是进程的CPU区间时间。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>饥饿——低优先级的进程可能永远无法满足</p><p>解决方法：老化——进程的优先级会随着数间的增长而提高</p><h2 id="优先级的计算"><a href="#优先级的计算" class="headerlink" title="优先级的计算"></a>优先级的计算</h2><p>普通进程的优先级是动态变化的，其计算公式为：</p><p><strong>优先级Priority &#x3D; 优先级基数base + NICE值 + CPU_PENALTY</strong></p><ul><li>优先级基数base等于40，前台进程的NICE值为20，后台进程的NICE值为24</li><li>普通用户可以使用nice或renice命令增加NICE值，root用户可以减小NICE值，但不能小于0</li><li>CPU_PENALTY的计算公式：<strong>CPU_PENALTY&#x3D;CPU_USAGE*R；</strong></li><li>R&#x3D;0.5；CPU_USAGE是记录某个进程使用CPU时间片数量的一个变量，处于运行态的进程，每经过一个时间周期，CPU_USAGE就加一。</li><li>所有的进程，每经过一秒钟，CPU_USAGE就发生一次变化：CPU_USAGE&#x3D;CPU_USAGE*D（D&#x3D;0.5）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2022/09/25/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/09/25/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="进程的不足"><a href="#进程的不足" class="headerlink" title="进程的不足"></a>进程的不足</h3><p>进程的两个基本属性：</p><ul><li>资源的拥有者：每个进程均有一虚拟地址，保存进程影像，控制内存、I&#x2F;O设备等资源，有状态、优先级、调度等。</li><li>调度单元：进程是一执行轨迹</li></ul><p>这两个属性构成了进程并发进行的基础</p><p>系统必须完成的操作：创建进程、撤销进程、进程切换</p><ul><li>当进程被创建时，系统要为它分配PCB和内存等必要的资源；当进程被终止时，系统需要回收这些资源，这就给系统增加了开销</li><li>当进程运行时，进程的来回切换也需要一定的系统资源来保存当前执行进程的CPU现场和为选中的进程重新布置CPU现场</li></ul><p>缺点：时间开销更大，限制了并发进行的程度。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li>目的：减少进程切换和创建撤销的开销，提高执行效率，节约资源</li><li>实现：将进程的资源申请和调度属性分开，进程只负责资源的申请和拥有，不负责资源的调度。资源的调度由线程来进行。</li><li>线程：是进程中的一个实体，负责资源的调度和分派。</li></ul><h2 id="单线程进程和多线程进程"><a href="#单线程进程和多线程进程" class="headerlink" title="单线程进程和多线程进程"></a>单线程进程和多线程进程</h2><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664110616170.png" alt="1664110616170"></p><p>线程是CPU运行的一个基本单位，包括：</p><ul><li>程序计数器</li><li>寄存器集</li><li>栈空间</li></ul><p>一个线程与它的对等线程共享：</p><ul><li>代码段</li><li>数据段</li><li>操作系统资源</li></ul><p><strong>传统的进程相当于只有一个线程的进程</strong></p><h3 id="单线程进程与多线程进程在实际应用上的比较"><a href="#单线程进程与多线程进程在实际应用上的比较" class="headerlink" title="单线程进程与多线程进程在实际应用上的比较"></a>单线程进程与多线程进程在实际应用上的比较</h3><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664111100222.png" alt="1664111100222"></p><p>以我们常用的word软件举例，假如进程中只有一个线程：</p><ul><li>当我们在文档第一页输入文字，会影响后文的排版，假如后文有成百上千页文档，则之后的排版需要数秒的时间来完成。在我们完成输入之后，输入进程进入Ready态，排版进程进入Running态。在排版进程运行中，输入进程不能执行，无法进行输入。</li><li>当我们在文档中进行了较多的修改，此时保存文档，保存进程运行中，输入进程不能进行，无法进行输入操作。</li></ul><p>而在实际情况下，通常存在着多个线程，保证了上述操作可以同时进行。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>响应度高：网页浏览（文本线程、图像线程……）</li><li>资源利用率高：进程创建的开销较大，而且当多个线程所需数据资源较为相似时，资源的利用率很高。</li><li>充分利用了多处理器体系结构</li></ul><h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><h2 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h2><ul><li>利用用户级的线程库进行管理</li><li>在用户层通过线程库来支持。三个主要的线程库：<br>POSIX Pthreads<br>Win32 threads<br>Java threads</li><li>线程库提供对线程的创建、调度和管理，无序用户干预</li><li>内核不知道现成的存在</li></ul><p><strong>缺点</strong>：如果内核是单线程的，那么当进程内一个用户级线程执行系统调用时就会引起整个进程的阻塞，即使进程内的其他线程可以正常执行</p><p><img src="/./image/%E7%BA%BF%E7%A8%8B/1664197976542.png" alt="1664197976542"></p><ol><li>a-&gt;b：进程2执行的程序进行了一次系统调用，阻塞了进程P（比如进行了一次I&#x2F;O），将控制权转交给了内核，内核启动了I&#x2F;O操作，并切换到另一个进程。根据线程库维护的数据结构，检测线程2依然处于运行态。</li><li>a-&gt;c：当进程P将时间片用完之后，控制转交给内核，内核将进程P置为就绪态并切换到另一个进程。根据线程库维护的数据结构，检测线程2依然处于运行态。</li><li>a-&gt;d：当线程2在运行过程中需要线程1执行产生足够资源，线程2进入阻塞态，线程1进入运行态。由于内核不知道线程的存在，而线程2只需进程P之内的资源而无需向外部申请资源，所以进程P依旧处于运行态。</li></ol><h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><ul><li>内核支持</li><li>操作系统内核负责线程的创建、调度和管理</li><li>内核直接管理线程，所以当一个线程进入阻塞态时，内核会调度当前进程下的其他线程来执行</li><li>在多处理器环境下，内核能在多个处理器下调度不同的线程执行</li></ul><p><strong>使用该策略实现线程的操作系统：</strong></p><ul><li>Windows XP&#x2F;2000</li><li>Solaris</li><li>Linux</li><li>Tru64 UNIX</li><li>Mac OS X</li></ul><h2 id="用户级线程和核心级线程的区别"><a href="#用户级线程和核心级线程的区别" class="headerlink" title="用户级线程和核心级线程的区别"></a>用户级线程和核心级线程的区别</h2><ol><li>线程的调度和切换时间：用户级线程的切换通常发生在同一应用进程下的线程之间，无需通过中断来进入OS的内核，而且切换策略也比较简单，因此其切换时间很快。而核心级线程的切换时间相对较慢。</li><li>系统调用：用户级线程在执行系统调用时，由于内核不知道线程的存在，只当做是进程的系统调用，所以会阻塞整个进程而切换到另一个进程，待系统调用执行完毕之后，才会继续执行原来进程。而在核心级线程中，线程是资源调度的基本单位，所以当一个线程执行系统调用时，内核仅仅阻塞该线程并且可以继续执行同一进程下的其他线程</li><li>线程执行时间：在用户级线程中，进程是执行的基本单位，而如果一个进程中设置了多个线程，那么平均分配到单个线程的执行时间就会减少。而在核心级线程中，单个线程是执行的基本单位，所以执行时间更多。</li></ol><h2 id="用户级线程和核心级线程的优缺点"><a href="#用户级线程和核心级线程的优缺点" class="headerlink" title="用户级线程和核心级线程的优缺点"></a>用户级线程和核心级线程的优缺点</h2><h3 id="用户级线程-1"><a href="#用户级线程-1" class="headerlink" title="用户级线程"></a>用户级线程</h3><p><strong>优点：</strong></p><ol><li>可以在不支持线程的操作系统中实现</li><li>创建和销毁线程、线程切换等线程的管理操作开销比内核线程少得多</li><li>允许每个进程定制自己的调度算法，线程管理更加灵活</li><li>线程的调度无序内核的参与，控制简单</li></ol><p><strong>缺点：</strong></p><ol><li>线程发生I&#x2F;O或者页面故障引发的阻塞时，整个进程也会阻塞</li><li>一个单独的进程内部没有时钟中断，所以不可能采用轮转调度的方法调度线程</li><li>多个处理器下，同一进程中的线程只能在一个处理器下分时复用</li></ol><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><p><strong>优点：</strong></p><ol><li>当有多个处理器时，同一进程的不同线程可以同时进行。</li><li>如果一个线程被阻塞，可以调度同一进程下的不同线程执行</li><li>所有能阻塞线程的的调用都以系统调用的形式实现</li></ol><p><strong>缺点：</strong></p><ol><li>代价大，性能较差</li></ol><h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><h3 id="Many-to-One模型"><a href="#Many-to-One模型" class="headerlink" title="Many-to-One模型"></a>Many-to-One模型</h3><p><strong>多个用户级线程映射到一个内核线程</strong></p><ul><li>线程管理由线程库在用户空间中执行，效率比较高</li><li>如果一个线程执行了阻塞系统调用，整个进程会被阻塞</li><li>任何时间下只有一个线程访问内核，并行性差（多核环境下）</li></ul><p>例子：</p><ul><li>Solaris Green Threads</li><li>GNU Portable Threads</li></ul><h3 id="One-to-One模型"><a href="#One-to-One模型" class="headerlink" title="One-to-One模型"></a>One-to-One模型</h3><p><strong>每个用户进程对应一个内核进程</strong></p><ul><li>并行性好</li><li>需要一一对应，资源开销大</li></ul><p>例子：</p><ul><li>Windows NT&#x2F;XP&#x2F;2000</li><li>Linux</li><li>Solaris 9 and later</li></ul><h3 id="Many-to-Many模型"><a href="#Many-to-Many模型" class="headerlink" title="Many-to-Many模型"></a>Many-to-Many模型</h3><p><strong>多个用户进程映射到多个内核进程</strong></p><ul><li>允许操作系统创建足够多的内核进程</li></ul><p>例子：</p><ul><li>Solaris prior to version 9</li><li>Windows NT&#x2F;2000 with the Threadfiber package</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2022/09/22/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/09/22/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h1><p><strong>并发：现代操作系统允许多个程序被加载入内存中并同时进行</strong></p><p>在单核CPU上，多个程序不可能在微观意义（纳秒级时间尺度）上同时进行，只能实现串行，但通过多道迅速来回切换执行不同程序，可以在宏观意义（秒级时间尺度）上同时进行。</p><p>假设有两个程序A、B执行时间均为40ms，如果他们轮流执行，总的执行时间为80ms，CPU的效率较低。而在两程序执行过程中，不可能每时每刻都在使用CPU，也会对其他设备进行使用，所以采用并发的方式执行多个程序可以有效地提高CPU的使用效率。</p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663843296075.png" alt="1663843296075"><img src="/./image/%E8%BF%9B%E7%A8%8B/1663843312802.png" alt="1663843312802"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>正在执行中的程序</li><li>一个具有一定独立性的程序在数据集合上的一次动态执行过程</li><li>系统进行资源分配和调度的基本单位</li></ul><p>进程是一个动态概念，程序是一个静态概念</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>结构特征：程序段、数据段、进程控制块PCB</li><li>动态性：最基本的特征，进程是动态产生、动态消亡的；进程在其生命周期内，有三种基本状态来切换（就绪、等待、执行）</li><li>并发性：任何进程都可以和其他进程一起向前推进</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位</li><li>异步性：每个进程都已其相对独立、不可预知的速度向前推进</li></ul><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><ul><li>代码段</li><li>数据段</li><li>堆</li><li>堆栈</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663844353578.png" alt="1663844353578"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p><strong>进程树：</strong></p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663844992620.png" alt="1663844992620"></p><h2 id="进程层次"><a href="#进程层次" class="headerlink" title="进程层次"></a>进程层次</h2><ul><li>在Unix操作系统中，所有的进程都由其他的进程生成，生成与被生成的进程为父子关系。</li><li>在上图所示的进程树中，init进程是所有用户进程的祖先进程。</li><li>在Windows系统下，进程之间都是平等的。</li></ul><h2 id="程序控制块（PCB）"><a href="#程序控制块（PCB）" class="headerlink" title="程序控制块（PCB）"></a>程序控制块（PCB）</h2><p><strong>PCB用于保存进程在执行过程中的重要信息，进程与PCB是一一对应的</strong></p><ul><li>进程存在的唯一标识</li><li>存储着OS所需的用于描述进程和控制进程的所有信息</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663845626478.png" alt="1663845626478"></p><p><strong>进程空间和大小</strong></p><ul><li>每个PCB都要占据一定的内存，PCB存贮在Process table中。</li><li>Process table的大小有限，所存储的PCB数量有限，所以并发进行的进程数有限</li></ul><h2 id="CPU在不同进程中的切换"><a href="#CPU在不同进程中的切换" class="headerlink" title="CPU在不同进程中的切换"></a>CPU在不同进程中的切换</h2><ul><li>当CPU切换到另一个进程时，需要保存老进程的状态，并且加载新系统的状态</li><li>不同进程的切换时额外的时间开销，在切换过程中CPU不会进行任何有效的工作</li><li>切换时间与硬件性能密切相关</li></ul><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663846217100.png" alt="1663846217100"></p><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p><strong>在进程执行时，它的状态会发生多次变化：</strong></p><ul><li>new：进程刚被创建</li><li>running：进程正在执行</li><li>blocked：进程等待某些资源就绪后才能执行</li><li>ready：进程所需资源准备完毕，等待CPU分配时间</li><li>terminated：进程终止、</li></ul><p><strong>进程在以下情况下会被生成：</strong></p><ul><li>系统初始化</li><li>正在运行的进程调用系统生成子进程</li><li>用户命令生成进程</li><li>批处理作业的生成</li></ul><p>进程的状态切换：</p><p><img src="/./image/%E8%BF%9B%E7%A8%8B/1663849046495.png" alt="1663849046495"></p><ul><li>Running：进程具有所需资源并正在CPU中运行</li><li>Ready：进程具有所需资源但正在等待CPU的分配</li><li>Blocked：进程不具备所需资源</li><li>1：进程在Running过程中发现所需资源不足，于是转入Blocked态</li><li>2：进程在Running过程中CPU所分配的时间耗尽，转入Ready态</li><li>3：进程得到CPU分配的时间，转入Running态</li><li>4：进程获得了执行所需资源，转入Ready态（只能被其他进程唤醒而不能自己转变）</li></ul><p><em>实际上，由于Running态和Ready态都具备运行所需的资源，所以将它们统称为Runnable态，并将它们储存在同一队列中。存在Scheduler指针，指向正在运行的进程，并以指针的变化来表示Running态和Ready态的变化。</em></p><p>进程的终止：</p><ul><li>进程在完成时自己终止</li><li>进程在碰见错误时终止</li><li>进程在收到其他进程的特定信号时终止</li></ul><p><em>当进程自己终止时它进入“僵尸”态</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux-Unix的基本命令(2)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/</url>
      
        <content type="html"><![CDATA[<p><strong>文件和目录基本操作命令</strong></p><h2 id="Shell命令特点"><a href="#Shell命令特点" class="headerlink" title="Shell命令特点"></a>Shell命令特点</h2><ul><li>Shell具有命令补齐（Command-Line Completion）的功能，它是指在键入的字符足以确定唯一一个文件时，按下 <code>&lt;Tab&gt;</code>键系统就会自动补齐该文件名的剩下部分。<br>例如：当键入 <code>&lt;[root@redflag /root] # hist&gt; </code>时，按下 <code>&lt;Tab&gt;</code>系统将会自动补齐 <code>&lt;[root@redflag /root] # history&gt;</code></li><li>Linux的命令区分大小写，且通常Linux的命令是小写的</li></ul><h2 id="ls命令-List-directory-contents"><a href="#ls命令-List-directory-contents" class="headerlink" title="ls命令-List directory contents"></a>ls命令-List directory contents</h2><ul><li>语法：ls[参数]文件名或路径</li><li>功能：列出文件或者子目录的信息</li><li>参数：<br><code>&lt;-a&gt;</code>：显示所有文件，包括以.开头的隐藏文件<br><code>&lt;-l&gt;</code>：以长格式显示文件或子目录的信息<br><code>&lt;-i&gt;</code>：显示每个文件的索引号<br><code>&lt;-R&gt;</code>：显示目录及下级子目录结构<br><code>&lt;-S&gt;</code>：以文件大小排序</li><li>ls -l以长格式显示文件或子目录的信息，如：<br><em>drwxr-xr-x 2 jjpr1 group 512 Nov 18 10：24</em><br><em>drwxrwxr-x 24 root auth 512 Nov 16 10：33</em></li><li>用颜色代表不同文件：<br>蓝色：目录<br>绿色：可执行文件<br>红色：压缩文件<br>浅蓝色：链接文件<br>灰色：其他文件</li><li>在ls -l显示结果中，第一个字符表示文件的类型：<br><code>&lt;d&gt;</code>：目录<br><code>&lt;-&gt;</code>：普通文件<br><code>&lt;c&gt;</code>：字符文件<br><code>&lt;b&gt;</code>：块设备<br><code>&lt;l&gt;</code>：链接文件</li><li>pwd - 打印用户当前所处目录</li><li>cd目录 - 改变当前目录</li></ul><h2 id="mkdir命令-make-directories-建立目录"><a href="#mkdir命令-make-directories-建立目录" class="headerlink" title="mkdir命令 - make directories 建立目录"></a>mkdir命令 - make directories 建立目录</h2><ul><li>语法：mkdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：当父目录不存在时，可将其连同子目录一起创建，即一次可建立多级目录<br><code>&lt;mkdir -p dir2/bak&gt;</code>：在dir2目录下建立子目录bak，如果dir2不存在则将它一同创立，在dir2目录事先存在时等同于 <code>&lt;mkdir dir2/bak&gt;</code></li></ul><h2 id="rmdir命令-remove-directories-删除目录"><a href="#rmdir命令-remove-directories-删除目录" class="headerlink" title="rmdir命令 - remove directories 删除目录"></a>rmdir命令 - remove directories 删除目录</h2><ul><li>语法：rmdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：一起删除父目录时父目录下应无其他目录<br><code>&lt;rmdir test&gt;</code>：删除当前目录下的test目录，被删除的test目录下应无其他文件或目录<br><code>&lt;rmdir -p longkey/test&gt;</code>：若longkey目录下除test外无其他目录或文件，则将它一同删除</li></ul><h2 id="cp命令-copy-files-复制文件"><a href="#cp命令-copy-files-复制文件" class="headerlink" title="cp命令 - copy files 复制文件"></a>cp命令 - copy files 复制文件</h2><ul><li>语法：cp [options] sourcefile destfile<br>cp [options] sourcefile … directory</li><li>作用：将一文件复制为另一文件，或是将多个文件复制到指定目录下</li><li>参数选项：<br><code>&lt;-p&gt;</code>：保持原始文件属性<br><code>&lt;-f&gt;</code>：如果目标文件已经存在，则覆盖它<br><code>&lt;-i&gt;</code>：提示是否要覆盖已有的目标文件<br><code>&lt;-r R&gt;</code>：递归复制目录，包括目录下的各级子目录。</li><li>目的目录不能在原目录下。如 <code>&lt;cp -r //targetdir&gt;</code>，会使系统进入死循环甚至瘫痪。<br><code>&lt;$ cp aaa bbb&gt;</code>：将文件aaa（已存在）复制并命名为bbb<br><code>&lt;$ cp *.c Finished&gt;</code>：将所有.c文件拷贝到Finished目录下</li></ul><h2 id="rm命令-remove-删除文件或目录"><a href="#rm命令-remove-删除文件或目录" class="headerlink" title="rm命令 - remove 删除文件或目录"></a>rm命令 - remove 删除文件或目录</h2><ul><li>语法：rm [-firR] file&#x2F;directory</li><li>参数选项：<br><code>&lt;-f&gt;</code>：不加提示的删除已存在的文件<br><code>&lt;-i&gt;</code>：交互删除<br><code>&lt;-r&gt;</code>：递归删除整个目录</li><li><code>&lt;rm -i *.c&gt;</code>：删除所有.c文件，并在删除前加以询问<br><code>&lt;rm -r finish&gt;</code>：删除finish目录下的所有文件和子目录</li></ul><h2 id="mv命令-move-移动文件或目录"><a href="#mv命令-move-移动文件或目录" class="headerlink" title="mv命令 - move 移动文件或目录"></a>mv命令 - move 移动文件或目录</h2><ul><li>语法：mv [-fi] source_file … target_directory<br>mv [-fi] source_file target_file</li><li>作用：将文件移动到指定目录下或将文件重命名</li><li>参数选项：<br><code>&lt;-f&gt;</code>：禁止提示<br><code>&lt;-i&gt;</code>：文件或目录重名时提示是否覆盖</li></ul><h2 id="tough命令-生成空文件或者修改文件的存取或修改时间"><a href="#tough命令-生成空文件或者修改文件的存取或修改时间" class="headerlink" title="tough命令 - 生成空文件或者修改文件的存取或修改时间"></a>tough命令 - 生成空文件或者修改文件的存取或修改时间</h2><ul><li>语法：tough [参数] 文件或者目录名</li><li>实例：</li><li><code>&lt;tough *&gt;</code> ：将当前目录下所有文件时间修改为当前系统时间<br><code>&lt;tough -d 20050912 test&gt;</code>：将文件test的时间修改为20050912<br><code>&lt;tough aaa&gt;</code>：如果aaa文件存在则将其修改为当前系统时间，如果不存在则创建文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux/Unix的基本命令(1)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>系统的登录、退出、启动和关闭</strong></p><ol><li>Linux是一个多用户的操作系统，注册用户想要使用Linux系统资源，必须登陆系统。</li><li>Linux将用户分为普通用户和超级用户。一般的Linux使用者均为普通用户，而系统管理员使用超级用户来进行文件管理等工作。</li><li>用户身份不同系统提示符也不同。<br>#：超级用户<br>$：普通用户</li></ol><h2 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h2><ol><li><p>系统启动后，输入用户名并键入回车符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login：root</span><br></pre></td></tr></table></figure></li><li><p>输入用户口令，输入的口令不会显示。如果输入错误，屏幕上会显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Login incorrect</span><br><span class="line">Login：</span><br></pre></td></tr></table></figure></li></ol><p>执行上述两步后，若屏幕显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loclhost root] #</span><br></pre></td></tr></table></figure><p>说明登录成功，可以进行操作</p><h2 id="系统退出"><a href="#系统退出" class="headerlink" title="系统退出"></a>系统退出</h2><p>用户在使用完成后退出系统的操作叫做注销，方法有三种：</p><ol><li>键入：exit</li><li>按Ctrl + D</li><li>logout</li></ol><h2 id="系统的启动与关闭"><a href="#系统的启动与关闭" class="headerlink" title="系统的启动与关闭"></a>系统的启动与关闭</h2><p>Linux在不使用系统资源时，需要关闭系统。必须由超级用户在shell提示符下，键入关闭命令，系统将完整的执行关闭所有进程，释放占用资源，停止运行。切断电源。</p><h3 id="关闭系统的命令："><a href="#关闭系统的命令：" class="headerlink" title="关闭系统的命令："></a>关闭系统的命令：</h3><p><code>[root@loclhost /root] # shutdown -h now</code></p><p><code>[root@loclhost /root] # halt</code></p><p><code>[root@loclhost /root] # init 0</code></p><p><code>[root@loclhost /root] # poweroff</code></p><h3 id="重启系统的命令："><a href="#重启系统的命令：" class="headerlink" title="重启系统的命令："></a>重启系统的命令：</h3><p>reboot 命令</p><p>shutdown -r <code>&lt;time&gt;</code> 命令</p><p>组合键Ctrl + Alt + Del</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/13/post1/"/>
      <url>/2022/09/13/post1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机是如何启动（boot）的？"><a href="#计算机是如何启动（boot）的？" class="headerlink" title="计算机是如何启动（boot）的？"></a>计算机是如何启动（boot）的？</h1><p><strong>计算机的启动分为四个阶段</strong></p><h2 id="第一阶段：BIOS（Basic-Input-x2F-Output-System）"><a href="#第一阶段：BIOS（Basic-Input-x2F-Output-System）" class="headerlink" title="第一阶段：BIOS（Basic Input&#x2F;Output System）"></a>第一阶段：BIOS（Basic Input&#x2F;Output System）</h2><ul><li>硬件自检：首先检查计算机硬件是否能够满足计算机运行的基本需求（Power-On Self-Test）</li><li>启动顺序：在BIOS完成对硬件的自检之后，会将控制权转交给下一阶段的启动程序，这时BIOS需要知道下一阶段的启动程序储存在何处，因此BIOS需要一个关于外部储存设备的排序，排在前面的设备优先转交控制权。这种排序被称为启动顺序（Boot Sequence）</li></ul><h2 id="第二阶段：主引导顺序"><a href="#第二阶段：主引导顺序" class="headerlink" title="第二阶段：主引导顺序"></a>第二阶段：主引导顺序</h2><ul><li>BIOS根据启动顺序将控制权转交给对应的外部储存设备。即根据用户指定的引导顺序从硬盘、软盘或是可移动设备中读取启动设备的MBR（Master Boot Recort），并放入指定内存位置0x7c00。</li></ul><p><strong>分区表：</strong></p><p>计算机读取该设备的第一个扇区，即该设备的前512个字节，来得到启动程序的具体位置。</p><p>如果该设备的第一个扇区最后两个字节是0x55和0xAA（二进制分别是01010101和10101010，0和1交替做识别码），则该设备储存了正确的启动程序；反之则需要将控制权按启动顺序转交给下一存储设备。<br><img src="/./post1/20220913211755.png"></p><h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><ul><li>计算机的控制权转交给硬盘的某个分区</li><li>该分区的第一个扇区被激活，叫主引导扇区（Volume boot record），用于告诉计算机操作系统在这个分区中的位置。然后计算机就会把操作系统加载到内存中。</li></ul><p><em>当计算机中存在多种操作系统时，计算机读取主引导扇区的前446字节的机械码之后，不会将控制权直接转交某一分区，而是启动事先安装的启动管理器（Boot Loader）,由用户选择使用哪一个操作系统。</em></p><p><img src="/./post1/20220913211814.png"></p><h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><ul><li>控制权转交操作系统之后，操作系统的内核首先被加载入内存中。</li><li>以Linux系统为例，先载入&#x2F;boot目录下的是kernel。</li><li>内核加载完毕后，第一个运行的程序是&#x2F;sbin&#x2F;init，他根据配置文件生成init进程。这是Linux系统启动后生成的第一个进程，pid进程编号为1，其他进程都是他的后代。</li><li>然后init进程加载系统的各个模块，例如窗口模块和网络模块，直到执行&#x2F;bin&#x2F;login程序，跳出登入界面，等待用户输入账号和密码。</li></ul><h1 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h1><h2 id="OS的目标"><a href="#OS的目标" class="headerlink" title="OS的目标"></a>OS的目标</h2><ul><li>提高系统资源的利用率：使计算机资源更好更充分的被用户利用</li><li>提高系统效率：效率的提高可以缩短完成每项任务的时间，提高<em>系统吞吐量</em></li><li>方便性：方便使用</li><li>可扩充性：系统功能的改变和结构的扩充不影响原有功能的使用</li><li>开放性：不同的计算机和设备能够被集成起来有效使用</li></ul><h2 id="推动操作系统发展的因素"><a href="#推动操作系统发展的因素" class="headerlink" title="推动操作系统发展的因素"></a>推动操作系统发展的因素</h2><ul><li>计算机硬件升级和新的硬件类型发展</li><li>用户需求扩大</li><li>计算机体系结构的不断发展</li><li>市场的激烈竞争，OS功能的不断完善</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
