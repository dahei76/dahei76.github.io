<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程</title>
      <link href="/2022/09/22/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/09/22/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h1><p><strong>并发：现代操作系统允许多个程序被加载入内存中并同时进行</strong></p><p>在单核CPU上，多个程序不可能在微观意义（纳秒级时间尺度）上同时进行，只能实现串行，但通过多道迅速来回切换执行不同程序，可以在宏观意义（秒级时间尺度）上同时进行。</p><p>假设有两个程序A、B执行时间均为40ms，如果他们轮流执行，总的执行时间为80ms，CPU的效率较低。而在两程序执行过程中，不可能每时每刻都在使用CPU，也会对其他设备进行使用，所以采用并发的方式执行多个程序可以有效地提高CPU的使用效率。</p><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663843296075.png" alt="1663843296075"><img src="/image/%E8%BF%9B%E7%A8%8B/1663843312802.png" alt="1663843312802"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>正在执行中的程序</li><li>一个具有一定独立性的程序在数据集合上的一次动态执行过程</li><li>系统进行资源分配和调度的基本单位</li></ul><p>进程是一个动态概念，程序是一个静态概念</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>结构特征：程序段、数据段、进程控制块PCB</li><li>动态性：最基本的特征，进程是动态产生、动态消亡的；进程在其生命周期内，有三种基本状态来切换（就绪、等待、执行）</li><li>并发性：任何进程都可以和其他进程一起向前推进</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位</li><li>异步性：每个进程都已其相对独立、不可预知的速度向前推进</li></ul><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><ul><li>代码段</li><li>数据段</li><li>堆</li><li>堆栈</li></ul><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663844353578.png" alt="1663844353578"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p><strong>进程树：</strong></p><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663844992620.png" alt="1663844992620"></p><h2 id="进程层次"><a href="#进程层次" class="headerlink" title="进程层次"></a>进程层次</h2><ul><li>在Unix操作系统中，所有的进程都由其他的进程生成，生成与被生成的进程为父子关系。</li><li>在上图所示的进程树中，init进程是所有用户进程的祖先进程。</li><li>在Windows系统下，进程之间都是平等的。</li></ul><h2 id="程序控制块（PCB）"><a href="#程序控制块（PCB）" class="headerlink" title="程序控制块（PCB）"></a>程序控制块（PCB）</h2><p><strong>PCB用于保存进程在执行过程中的重要信息，进程与PCB是一一对应的</strong></p><ul><li>进程存在的唯一标识</li><li>存储着OS所需的用于描述进程和控制进程的所有信息</li></ul><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663845626478.png" alt="1663845626478"></p><p><strong>进程空间和大小</strong></p><ul><li>每个PCB都要占据一定的内存，PCB存贮在Process table中。</li><li>Process table的大小有限，所存储的PCB数量有限，所以并发进行的进程数有限</li></ul><h2 id="CPU在不同进程中的切换"><a href="#CPU在不同进程中的切换" class="headerlink" title="CPU在不同进程中的切换"></a>CPU在不同进程中的切换</h2><ul><li>当CPU切换到另一个进程时，需要保存老进程的状态，并且加载新系统的状态</li><li>不同进程的切换时额外的时间开销，在切换过程中CPU不会进行任何有效的工作</li><li>切换时间与硬件性能密切相关</li></ul><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663846217100.png" alt="1663846217100"></p><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p><strong>在进程执行时，它的状态会发生多次变化：</strong></p><ul><li>new：进程刚被创建</li><li>running：进程正在执行</li><li>blocked：进程等待某些资源就绪后才能执行</li><li>ready：进程所需资源准备完毕，等待CPU分配时间</li><li>terminated：进程终止、</li></ul><p><strong>进程在以下情况下会被生成：</strong></p><ul><li>系统初始化</li><li>正在运行的进程调用系统生成子进程</li><li>用户命令生成进程</li><li>批处理作业的生成</li></ul><p>进程的状态切换：</p><p><img src="/image/%E8%BF%9B%E7%A8%8B/1663849046495.png" alt="1663849046495"></p><ul><li>Running：进程具有所需资源并正在CPU中运行</li><li>Ready：进程具有所需资源但正在等待CPU的分配</li><li>Blocked：进程不具备所需资源</li><li>1：进程在Running过程中发现所需资源不足，于是转入Blocked态</li><li>2：进程在Running过程中CPU所分配的时间耗尽，转入Ready态</li><li>3：进程得到CPU分配的时间，转入Running态</li><li>4：进程获得了执行所需资源，转入Ready态（只能被其他进程唤醒而不能自己转变）</li></ul><p><em>实际上，由于Running态和Ready态都具备运行所需的资源，所以将它们统称为Runnable态，并将它们储存在同一队列中。存在Scheduler指针，指向正在运行的进程，并以指针的变化来表示Running态和Ready态的变化。</em></p><p>进程的终止：</p><ul><li>进程在完成时自己终止</li><li>进程在碰见错误时终止</li><li>进程在收到其他进程的特定信号时终止</li></ul><p><em>当进程自己终止时它进入“僵尸”态</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux-Unix的基本命令(2)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/</url>
      
        <content type="html"><![CDATA[<p><strong>文件和目录基本操作命令</strong></p><h2 id="Shell命令特点"><a href="#Shell命令特点" class="headerlink" title="Shell命令特点"></a>Shell命令特点</h2><ul><li>Shell具有命令补齐（Command-Line Completion）的功能，它是指在键入的字符足以确定唯一一个文件时，按下 <code>&lt;Tab&gt;</code>键系统就会自动补齐该文件名的剩下部分。<br>例如：当键入 <code>&lt;[root@redflag /root] # hist&gt; </code>时，按下 <code>&lt;Tab&gt;</code>系统将会自动补齐 <code>&lt;[root@redflag /root] # history&gt;</code></li><li>Linux的命令区分大小写，且通常Linux的命令是小写的</li></ul><h2 id="ls命令-List-directory-contents"><a href="#ls命令-List-directory-contents" class="headerlink" title="ls命令-List directory contents"></a>ls命令-List directory contents</h2><ul><li>语法：ls[参数]文件名或路径</li><li>功能：列出文件或者子目录的信息</li><li>参数：<br><code>&lt;-a&gt;</code>：显示所有文件，包括以.开头的隐藏文件<br><code>&lt;-l&gt;</code>：以长格式显示文件或子目录的信息<br><code>&lt;-i&gt;</code>：显示每个文件的索引号<br><code>&lt;-R&gt;</code>：显示目录及下级子目录结构<br><code>&lt;-S&gt;</code>：以文件大小排序</li><li>ls -l以长格式显示文件或子目录的信息，如：<br><em>drwxr-xr-x 2 jjpr1 group 512 Nov 18 10：24</em><br><em>drwxrwxr-x 24 root auth 512 Nov 16 10：33</em></li><li>用颜色代表不同文件：<br>蓝色：目录<br>绿色：可执行文件<br>红色：压缩文件<br>浅蓝色：链接文件<br>灰色：其他文件</li><li>在ls -l显示结果中，第一个字符表示文件的类型：<br><code>&lt;d&gt;</code>：目录<br><code>&lt;-&gt;</code>：普通文件<br><code>&lt;c&gt;</code>：字符文件<br><code>&lt;b&gt;</code>：块设备<br><code>&lt;l&gt;</code>：链接文件</li><li>pwd - 打印用户当前所处目录</li><li>cd目录 - 改变当前目录</li></ul><h2 id="mkdir命令-make-directories-建立目录"><a href="#mkdir命令-make-directories-建立目录" class="headerlink" title="mkdir命令 - make directories 建立目录"></a>mkdir命令 - make directories 建立目录</h2><ul><li>语法：mkdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：当父目录不存在时，可将其连同子目录一起创建，即一次可建立多级目录<br><code>&lt;mkdir -p dir2/bak&gt;</code>：在dir2目录下建立子目录bak，如果dir2不存在则将它一同创立，在dir2目录事先存在时等同于 <code>&lt;mkdir dir2/bak&gt;</code></li></ul><h2 id="rmdir命令-remove-directories-删除目录"><a href="#rmdir命令-remove-directories-删除目录" class="headerlink" title="rmdir命令 - remove directories 删除目录"></a>rmdir命令 - remove directories 删除目录</h2><ul><li>语法：rmdir [参数] 目录名</li><li>参数选项：<br><code>&lt;-p&gt;</code>：一起删除父目录时父目录下应无其他目录<br><code>&lt;rmdir test&gt;</code>：删除当前目录下的test目录，被删除的test目录下应无其他文件或目录<br><code>&lt;rmdir -p longkey/test&gt;</code>：若longkey目录下除test外无其他目录或文件，则将它一同删除</li></ul><h2 id="cp命令-copy-files-复制文件"><a href="#cp命令-copy-files-复制文件" class="headerlink" title="cp命令 - copy files 复制文件"></a>cp命令 - copy files 复制文件</h2><ul><li>语法：cp [options] sourcefile destfile<br>cp [options] sourcefile … directory</li><li>作用：将一文件复制为另一文件，或是将多个文件复制到指定目录下</li><li>参数选项：<br><code>&lt;-p&gt;</code>：保持原始文件属性<br><code>&lt;-f&gt;</code>：如果目标文件已经存在，则覆盖它<br><code>&lt;-i&gt;</code>：提示是否要覆盖已有的目标文件<br><code>&lt;-r R&gt;</code>：递归复制目录，包括目录下的各级子目录。</li><li>目的目录不能在原目录下。如 <code>&lt;cp -r //targetdir&gt;</code>，会使系统进入死循环甚至瘫痪。<br><code>&lt;$ cp aaa bbb&gt;</code>：将文件aaa（已存在）复制并命名为bbb<br><code>&lt;$ cp *.c Finished&gt;</code>：将所有.c文件拷贝到Finished目录下</li></ul><h2 id="rm命令-remove-删除文件或目录"><a href="#rm命令-remove-删除文件或目录" class="headerlink" title="rm命令 - remove 删除文件或目录"></a>rm命令 - remove 删除文件或目录</h2><ul><li>语法：rm [-firR] file&#x2F;directory</li><li>参数选项：<br><code>&lt;-f&gt;</code>：不加提示的删除已存在的文件<br><code>&lt;-i&gt;</code>：交互删除<br><code>&lt;-r&gt;</code>：递归删除整个目录</li><li><code>&lt;rm -i *.c&gt;</code>：删除所有.c文件，并在删除前加以询问<br><code>&lt;rm -r finish&gt;</code>：删除finish目录下的所有文件和子目录</li></ul><h2 id="mv命令-move-移动文件或目录"><a href="#mv命令-move-移动文件或目录" class="headerlink" title="mv命令 - move 移动文件或目录"></a>mv命令 - move 移动文件或目录</h2><ul><li>语法：mv [-fi] source_file … target_directory<br>mv [-fi] source_file target_file</li><li>作用：将文件移动到指定目录下或将文件重命名</li><li>参数选项：<br><code>&lt;-f&gt;</code>：禁止提示<br><code>&lt;-i&gt;</code>：文件或目录重名时提示是否覆盖</li></ul><h2 id="tough命令-生成空文件或者修改文件的存取或修改时间"><a href="#tough命令-生成空文件或者修改文件的存取或修改时间" class="headerlink" title="tough命令 - 生成空文件或者修改文件的存取或修改时间"></a>tough命令 - 生成空文件或者修改文件的存取或修改时间</h2><ul><li>语法：tough [参数] 文件或者目录名</li><li>实例：</li><li><code>&lt;tough *&gt;</code> ：将当前目录下所有文件时间修改为当前系统时间<br><code>&lt;tough -d 20050912 test&gt;</code>：将文件test的时间修改为20050912<br><code>&lt;tough aaa&gt;</code>：如果aaa文件存在则将其修改为当前系统时间，如果不存在则创建文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux/Unix的基本命令(1)</title>
      <link href="/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/18/%E4%BD%BF%E7%94%A8Linux-Unix%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>系统的登录、退出、启动和关闭</strong></p><ol><li>Linux是一个多用户的操作系统，注册用户想要使用Linux系统资源，必须登陆系统。</li><li>Linux将用户分为普通用户和超级用户。一般的Linux使用者均为普通用户，而系统管理员使用超级用户来进行文件管理等工作。</li><li>用户身份不同系统提示符也不同。<br>#：超级用户<br>$：普通用户</li></ol><h2 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h2><ol><li><p>系统启动后，输入用户名并键入回车符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login：root</span><br></pre></td></tr></table></figure></li><li><p>输入用户口令，输入的口令不会显示。如果输入错误，屏幕上会显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Login incorrect</span><br><span class="line">Login：</span><br></pre></td></tr></table></figure></li></ol><p>执行上述两步后，若屏幕显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loclhost root] #</span><br></pre></td></tr></table></figure><p>说明登录成功，可以进行操作</p><h2 id="系统退出"><a href="#系统退出" class="headerlink" title="系统退出"></a>系统退出</h2><p>用户在使用完成后退出系统的操作叫做注销，方法有三种：</p><ol><li>键入：exit</li><li>按Ctrl + D</li><li>logout</li></ol><h2 id="系统的启动与关闭"><a href="#系统的启动与关闭" class="headerlink" title="系统的启动与关闭"></a>系统的启动与关闭</h2><p>Linux在不使用系统资源时，需要关闭系统。必须由超级用户在shell提示符下，键入关闭命令，系统将完整的执行关闭所有进程，释放占用资源，停止运行。切断电源。</p><h3 id="关闭系统的命令："><a href="#关闭系统的命令：" class="headerlink" title="关闭系统的命令："></a>关闭系统的命令：</h3><p><code>[root@loclhost /root] # shutdown -h now</code></p><p><code>[root@loclhost /root] # halt</code></p><p><code>[root@loclhost /root] # init 0</code></p><p><code>[root@loclhost /root] # poweroff</code></p><h3 id="重启系统的命令："><a href="#重启系统的命令：" class="headerlink" title="重启系统的命令："></a>重启系统的命令：</h3><p>reboot 命令</p><p>shutdown -r <code>&lt;time&gt;</code> 命令</p><p>组合键Ctrl + Alt + Del</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/13/post1/"/>
      <url>/2022/09/13/post1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机是如何启动（boot）的？"><a href="#计算机是如何启动（boot）的？" class="headerlink" title="计算机是如何启动（boot）的？"></a>计算机是如何启动（boot）的？</h1><p><strong>计算机的启动分为四个阶段</strong></p><h2 id="第一阶段：BIOS（Basic-Input-x2F-Output-System）"><a href="#第一阶段：BIOS（Basic-Input-x2F-Output-System）" class="headerlink" title="第一阶段：BIOS（Basic Input&#x2F;Output System）"></a>第一阶段：BIOS（Basic Input&#x2F;Output System）</h2><ul><li>硬件自检：首先检查计算机硬件是否能够满足计算机运行的基本需求（Power-On Self-Test）</li><li>启动顺序：在BIOS完成对硬件的自检之后，会将控制权转交给下一阶段的启动程序，这时BIOS需要知道下一阶段的启动程序储存在何处，因此BIOS需要一个关于外部储存设备的排序，排在前面的设备优先转交控制权。这种排序被称为启动顺序（Boot Sequence）</li></ul><h2 id="第二阶段：主引导顺序"><a href="#第二阶段：主引导顺序" class="headerlink" title="第二阶段：主引导顺序"></a>第二阶段：主引导顺序</h2><ul><li>BIOS根据启动顺序将控制权转交给对应的外部储存设备。即根据用户指定的引导顺序从硬盘、软盘或是可移动设备中读取启动设备的MBR（Master Boot Recort），并放入指定内存位置0x7c00。</li></ul><p><strong>分区表：</strong></p><p>计算机读取该设备的第一个扇区，即该设备的前512个字节，来得到启动程序的具体位置。</p><p>如果该设备的第一个扇区最后两个字节是0x55和0xAA（二进制分别是01010101和10101010，0和1交替做识别码），则该设备储存了正确的启动程序；反之则需要将控制权按启动顺序转交给下一存储设备。<br><img src="/./post1/20220913211755.png"></p><h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><ul><li>计算机的控制权转交给硬盘的某个分区</li><li>该分区的第一个扇区被激活，叫主引导扇区（Volume boot record），用于告诉计算机操作系统在这个分区中的位置。然后计算机就会把操作系统加载到内存中。</li></ul><p><em>当计算机中存在多种操作系统时，计算机读取主引导扇区的前446字节的机械码之后，不会将控制权直接转交某一分区，而是启动事先安装的启动管理器（Boot Loader）,由用户选择使用哪一个操作系统。</em></p><p><img src="/./post1/20220913211814.png"></p><h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><ul><li>控制权转交操作系统之后，操作系统的内核首先被加载入内存中。</li><li>以Linux系统为例，先载入&#x2F;boot目录下的是kernel。</li><li>内核加载完毕后，第一个运行的程序是&#x2F;sbin&#x2F;init，他根据配置文件生成init进程。这是Linux系统启动后生成的第一个进程，pid进程编号为1，其他进程都是他的后代。</li><li>然后init进程加载系统的各个模块，例如窗口模块和网络模块，直到执行&#x2F;bin&#x2F;login程序，跳出登入界面，等待用户输入账号和密码。</li></ul><h1 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h1><h2 id="OS的目标"><a href="#OS的目标" class="headerlink" title="OS的目标"></a>OS的目标</h2><ul><li>提高系统资源的利用率：使计算机资源更好更充分的被用户利用</li><li>提高系统效率：效率的提高可以缩短完成每项任务的时间，提高<em>系统吞吐量</em></li><li>方便性：方便使用</li><li>可扩充性：系统功能的改变和结构的扩充不影响原有功能的使用</li><li>开放性：不同的计算机和设备能够被集成起来有效使用</li></ul><h2 id="推动操作系统发展的因素"><a href="#推动操作系统发展的因素" class="headerlink" title="推动操作系统发展的因素"></a>推动操作系统发展的因素</h2><ul><li>计算机硬件升级和新的硬件类型发展</li><li>用户需求扩大</li><li>计算机体系结构的不断发展</li><li>市场的激烈竞争，OS功能的不断完善</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
